

# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: blickfeld/percept_pipeline/config/background_subtraction.proto, blickfeld/percept_pipeline/config/data_source.proto, blickfeld/percept_pipeline/config/perception.proto, blickfeld/percept_pipeline/config/point_cloud_filter.proto, blickfeld/percept_pipeline/config/zone_algorithm.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List

import blickfeld_qb2.betterproto as betterproto
import blickfeld_qb2.betterproto.lib.google.protobuf as betterproto_lib_google_protobuf

from ...base import geometry as __base_geometry__


@dataclass(eq=False, repr=False)
class PointCloudFilter(betterproto.Message):
    """Algorithm for filtering point clouds"""

    radius_outlier: "PointCloudFilterRadiusOutlier" = betterproto.message_field(
        1, group="point_cloud_filter_type"
    )
    """Use radius outlier filter for noise reduction on point clouds"""


@dataclass(eq=False, repr=False)
class PointCloudFilterRadiusOutlier(betterproto.Message):
    """Filter points based on the number of neighbors in a certain radius"""

    min_neighbor_points: int = betterproto.uint32_field(1)
    """Minimum number of neighbors a point has to have to be retained"""

    neighbor_radius: float = betterproto.double_field(2)
    """All points within this radius are considered neighbors of a point"""


@dataclass(eq=False, repr=False)
class BackgroundSubtraction(betterproto.Message):
    """
    Algorithms seperating the input point cloud into foreground and background.
    """

    mixture_of_gaussians: "BackgroundSubtractionMixtureOfGaussians" = (
        betterproto.message_field(1, group="background_subtraction_type")
    )
    """Use mixture of gaussians for foreground/background detection"""

    octree: "BackgroundSubtractionOctree" = betterproto.message_field(
        3, group="background_subtraction_type"
    )
    """Use a static octree for foreground/background detection."""


@dataclass(eq=False, repr=False)
class BackgroundSubtractionMixtureOfGaussians(betterproto.Message):
    """
    Dynamic background subtraction using a mixture of gaussians. The algorithm
    automatically slowly updates the background model if the scene changes. The
    update rate is controlled via 'exponential_decay'.
    """

    num_initialization_frames: int = betterproto.uint32_field(1)
    """
    How many frames of the first received frames are used to build the
    background Reasonable default: 10
    """

    exponential_decay: float = betterproto.float_field(2)
    """
    Controls how fast objects switch between foreground and background.
    Exponential decay factor. Reasonable default: 0.005
    """

    min_weight_threshold_for_background: float = betterproto.float_field(3)
    """
    Controls how much noise the background/foreground is expected to have.
    Reasonable default: 0.25
    """


@dataclass(eq=False, repr=False)
class BackgroundSubtractionOctree(betterproto.Message):
    """
    Uses the first received frames to build a static background map of the
    environment. The algorithm requires the scene to only contain the static
    parts of the scene on the start of the processing. The background model is
    not updated automatically afterwards. The ResetBackground grpc method
    allows to update the static map of the environment.
    """

    num_initialization_frames: int = betterproto.uint32_field(1)
    """
    How many frames of the first received frames are used to build the
    background Reasonable default: 10
    """


@dataclass(eq=False, repr=False)
class DataSource(betterproto.Message):
    """
    The configuration storing the sources to retrieve the point cloud data for
    further processing.
    """

    cube1_setup: "DataSourceCube1Setup" = betterproto.message_field(
        1, group="data_source_type"
    )
    """Use Cube 1 lidars to retrieve point clouds"""

    qb2_setup: "DataSourceQb2Setup" = betterproto.message_field(
        3, group="data_source_type"
    )
    """Use Qb2 lidars to retrieve point clouds"""


@dataclass(eq=False, repr=False)
class DataSourceCube1(betterproto.Message):
    """Configuration for retrieving point clouds from a Cube 1"""

    fqdn: str = betterproto.string_field(1)
    """The fully qualified domain name of the Cube 1"""

    map_from_lidar: "__base_geometry__.Transform" = betterproto.message_field(2)
    """
    Transformation from the lidar frame to the map frame. If this transform is
    not set, this will be interpreted as identify transformation. Transforming
    all point cloud topics into the map frame results in a globally consistent
    combined point cloud in map frame.
    """


@dataclass(eq=False, repr=False)
class DataSourceQb2(betterproto.Message):
    """Configuration for retrieving point clouds from a Qb2"""

    fqdn: str = betterproto.string_field(1)
    """
    The fully qualified domain name of the Qb2 device. For on-device
    processing/configuration, 'fqdn' can be set to an empty string to request
    the data of the current device.
    """

    map_from_lidar: "__base_geometry__.Transform" = betterproto.message_field(2)
    """
    Transformation from the lidar frame to the map frame. If this transform is
    not set, this will be interpreted as identify transformation. Transforming
    all point cloud topics into the map frame results in a globally consistent
    combined point cloud in map frame.
    """


@dataclass(eq=False, repr=False)
class DataSourceCube1Setup(betterproto.Message):
    """The configuration of a Cube 1 setup of the LiDAR devices"""

    lidars: List["DataSourceCube1"] = betterproto.message_field(1)
    """Cube1 lidars to retrieve the point clouds from"""

    enable_time_sync: bool = betterproto.bool_field(2)
    """
    If true: The same NTP server needs to be configured for each device before
    starting. The lidar clock and and scan-patterns will be continously
    synchronized. Recommended in multi-sensor setups. If false: the lidar
    measurements are timestamps with the receive time by the system. The
    receive time is less accurate if the network is not reliable.
    """


@dataclass(eq=False, repr=False)
class DataSourceTrigger(betterproto.Message):
    """
    Configuration of Trigger Mode. In trigger mode the processing pipeline will
    reduce the frequency at which point clouds and state lists are getting
    computed to reduce the amount of data transmitted between the processing
    device and configured 'lidars'.
    """

    frequency: float = betterproto.float_field(1)
    """
    The frequency at which data is getting requested from the lidars and
    outputs are generated.
    """


@dataclass(eq=False, repr=False)
class DataSourceQb2Setup(betterproto.Message):
    """The configuration of a Qb2 setup of the LiDAR devices"""

    lidars: List["DataSourceQb2"] = betterproto.message_field(1)
    """the qb2 lidars to get the point clouds from"""

    trigger: "DataSourceTrigger" = betterproto.message_field(2)
    """
    If the field is set trigger mode is enabled. If the field is not set, the
    pipeline outputs are computed with the frequency of configured lidars, i.e.
    the scan pattern configured on those.
    """


@dataclass(eq=False, repr=False)
class Perception(betterproto.Message):
    """
    The configuration of perception algorithms used to run e.g. security zones
    """

    background_subtraction: "BackgroundSubtraction" = betterproto.message_field(1)
    """Extract the foreground point cloud of the scene"""

    foreground_point_cloud_filters: List[
        "PointCloudFilter"
    ] = betterproto.message_field(2)
    """Filter the foreground point cloud"""


@dataclass(eq=False, repr=False)
class ZoneAlgorithm(betterproto.Message):
    """An algorithm that monitors the area within and around a zone."""

    name: str = betterproto.string_field(1)
    """The user readable zone algorithm name"""

    uuid: str = betterproto.string_field(2)
    """The uuid of the zone algorithm (uuid4)"""

    shape: "__base_geometry__.Shape" = betterproto.message_field(3)
    """
    Geometric shape (usually a Box) in which the algorithm detects certain
    behaviors/scenarios
    """

    volume: "ZoneAlgorithmVolume" = betterproto.message_field(9, group="algorithm_type")
    """Run volume monitoring within the zone"""

    security: "ZoneAlgorithmSecurity" = betterproto.message_field(
        7, group="algorithm_type"
    )
    """Run alarm detection within the zone"""

    exclusion: "ZoneAlgorithmExclusion" = betterproto.message_field(
        10, group="algorithm_type"
    )
    """Run exclusion zone"""


@dataclass(eq=False, repr=False)
class ZoneAlgorithmVolume(betterproto.Message):
    """
    Algorithm that measure the volume of a zone The volume of a zone is
    approximated by computing a 'volume map' from the input point clouds. The
    volume map discretize the zone into 'tiles' in the xy-plane with a side-
    length of 'resolution'. Each tile contains the height information about the
    points that fall into this tile. The volume of the volume map can be
    calculated by adding up the volumes of the tiles in the volume map.
    """

    resolution: float = betterproto.float_field(1)
    """
    Grid resolution per tile used to measure the volume. Reasonable default:
    0.1
    """

    empty_volume: float = betterproto.float_field(2)
    """
    The measured volume while area covered by the zone is considered 'empty'.
    The value can be set using TareVolume method while the area of the zone is
    empty. Reasonable default: 0
    """


@dataclass(eq=False, repr=False)
class ZoneAlgorithmSecurity(betterproto.Message):
    """
    Algorithm that triggers an alarm if movement was detected in the zone
    """

    min_points: int = betterproto.uint32_field(1)
    """
    Minimum number of (foreground) points in the security zone to trigger the
    alarm. Reasonable default: 10
    """

    max_points: int = betterproto.uint32_field(2)
    """
    Maximum number of (foreground) points in the security zone that still
    triggers an alarm. More points will disable the alarm. This logic can be
    disabled by setting max_points to '0'. Default: 0
    """


@dataclass(eq=False, repr=False)
class ZoneAlgorithmExclusion(betterproto.Message):
    """Algorithm that excludes points from the input point cloud"""

    pass
