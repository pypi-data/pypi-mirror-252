"""Generated by Sideko (sideko.dev)"""
import typing

import httpx

from beehiiv_api.schemas import *
import beehiiv_api.auth as sdk_auth
import beehiiv_api.errors as sdk_errors
import beehiiv_api.response as sdk_response


T = typing.TypeVar("T")


class AsyncClient:
    def __init__(
        self,
        *,
        bearer_auth: typing.Optional[str] = None,
        base_url: typing.Optional[str] = None,
    ):
        url = base_url or "https://api.beehiiv.com/v2"
        self.base_url = url
        self.session = httpx.AsyncClient()

        # register auth providers
        self._auth: typing.Dict[str, sdk_auth.AuthProvider] = {}
        self._auth["bearerAuth"] = sdk_auth.AuthBearer(val=bearer_auth)

    def _to_json_encodable(self, target: typing.Any) -> typing.Any:
        if isinstance(target, list):
            return [self._to_json_encodable(el) for el in target]

        dump_method = getattr(target, "model_api_dump", None)
        if callable(dump_method):
            return target.model_api_dump()

        return target

    def _add_auth(self, auth_names: typing.List[str], **req_kwargs) -> typing.Dict:
        for auth_name in auth_names:
            provider = self._auth.get(auth_name, None)
            if provider is not None:
                req_kwargs = provider.add_auth(req_kwargs)

        return req_kwargs

    async def delete_publications_publication_id_custom_fields(
        self, *, publication_id: str, id: str
    ) -> DeletePublicationsPublicationIdCustomFieldsIdResponse:
        """
        Delete a custom field from a publication
        """
        _endpoint = f"/publications/{publication_id}/custom_fields/{id}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.delete(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=DeletePublicationsPublicationIdCustomFieldsIdResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def delete_posts_post_id(
        self, *, publication_id: str, post_id: str
    ) -> typing.Dict[str, typing.Any]:
        """
        Delete or Archive a post. Any post that has been confirmed will have it's status changed to `archived`. Posts in the `draft` status will be permenantly deleted.
        """
        _endpoint = f"/publications/{publication_id}/posts/{post_id}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.delete(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=204,
                expected_type=typing.Dict[str, typing.Any],
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def delete_publications_publication_id_segments_segment_id(
        self, *, publication_id: str, segment_id: str
    ) -> typing.Dict[str, typing.Any]:
        """
        Delete a segment. Deleting the segment does not effect the subscriptions in the segment.
        """
        _endpoint = f"/publications/{publication_id}/segments/{segment_id}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.delete(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=204,
                expected_type=typing.Dict[str, typing.Any],
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def delete_subscriptions_subscription_id(
        self, *, publication_id: str, subscription_id: str
    ) -> typing.Dict[str, typing.Any]:
        """
        Delete a subscription.

        **This cannot be undone** All data associated with the subscription will also be deleted. We recommend unsubscribing when possible instead of deleting.

        If a premium subscription is deleted they will no longer be billed.
        """
        _endpoint = f"/publications/{publication_id}/subscriptions/{subscription_id}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.delete(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=204,
                expected_type=typing.Dict[str, typing.Any],
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def get_publications(
        self,
        *,
        direction: typing.Optional[GetPublicationsDirectionEnum] = None,
        expand: typing.Optional[typing.List[GetPublicationsExpandItemEnum]] = None,
        limit: typing.Optional[int] = None,
        order_by: typing.Optional[GetPublicationsOrderByEnum] = None,
        page: typing.Optional[int] = None,
    ) -> GetPublicationsResponse:
        """
        Retrieve all publications associated with your API key.
        """
        _endpoint = f"/publications"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if direction is not None:
            _params["direction"] = direction
        if expand is not None:
            _params["expand[]"] = expand
        if limit is not None:
            _params["limit"] = limit
        if order_by is not None:
            _params["order_by"] = order_by
        if page is not None:
            _params["page"] = page
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetPublicationsResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def get_publications_publication_id(
        self,
        *,
        publication_id: str,
        expand: typing.Optional[
            typing.List[GetPublicationsPublicationIdExpandItemEnum]
        ] = None,
    ) -> GetPublicationsPublicationIdResponse:
        """
        Retrieve a single publication
        """
        _endpoint = f"/publications/{publication_id}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if expand is not None:
            _params["expand[]"] = expand
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetPublicationsPublicationIdResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def get_subscription_updates_for_publiciation(
        self, *, publication_id: str
    ) -> GetPublicationsPublicationIdBulkSubscriptionUpdatesResponse:
        """
        Returns a list of Subscription Update objects for a publication
        """
        _endpoint = f"/publications/{publication_id}/bulk_subscription_updates"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetPublicationsPublicationIdBulkSubscriptionUpdatesResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def get_publications_publication_id_subcription_updates_id(
        self, *, publication_id: str, id: str
    ) -> GetPublicationsPublicationIdBulkSubscriptionUpdatesIdResponse:
        """
        Returns a single Subscription Update object for a publication
        """
        _endpoint = f"/publications/{publication_id}/bulk_subscription_updates/{id}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetPublicationsPublicationIdBulkSubscriptionUpdatesIdResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def get_publications_publication_id_custom_fields(
        self, *, publication_id: str
    ) -> GetPublicationsPublicationIdCustomFieldsResponse:
        """
        Retrieve all custom fields belonging to a specific publication
        """
        _endpoint = f"/publications/{publication_id}/custom_fields"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetPublicationsPublicationIdCustomFieldsResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def get_publications_publication_id_custom_fields_id(
        self, *, publication_id: str, id: str
    ) -> GetPublicationsPublicationIdCustomFieldsIdResponse:
        """
        View a specific custom field on a publication
        """
        _endpoint = f"/publications/{publication_id}/custom_fields/{id}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetPublicationsPublicationIdCustomFieldsIdResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def get_publications_publication_id_email_blasts(
        self,
        *,
        publication_id: str,
        direction: typing.Optional[
            GetPublicationsPublicationIdEmailBlastsDirectionEnum
        ] = None,
        expand: typing.Optional[
            typing.List[GetPublicationsPublicationIdEmailBlastsExpandItemEnum]
        ] = None,
        limit: typing.Optional[int] = None,
        order_by: typing.Optional[
            GetPublicationsPublicationIdEmailBlastsOrderByEnum
        ] = None,
        page: typing.Optional[int] = None,
    ) -> GetPublicationsPublicationIdEmailBlastsResponse:
        """
        Retrieve all Email Blasts
        """
        _endpoint = f"/publications/{publication_id}/email_blasts"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if direction is not None:
            _params["direction"] = direction
        if expand is not None:
            _params["expand[]"] = expand
        if limit is not None:
            _params["limit"] = limit
        if order_by is not None:
            _params["order_by"] = order_by
        if page is not None:
            _params["page"] = page
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetPublicationsPublicationIdEmailBlastsResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def get_publications_publication_id_email_blasts_email_blast_id(
        self,
        *,
        publication_id: str,
        email_blast_id: str,
        expand: typing.Optional[
            typing.List[
                GetPublicationsPublicationIdEmailBlastsEmailBlastIdExpandItemEnum
            ]
        ] = None,
    ) -> GetPublicationsPublicationIdEmailBlastsEmailBlastIdResponse:
        """
        Retrieve an Email Blast
        """
        _endpoint = f"/publications/{publication_id}/email_blasts/{email_blast_id}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if expand is not None:
            _params["expand[]"] = expand
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetPublicationsPublicationIdEmailBlastsEmailBlastIdResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def get_posts(
        self,
        *,
        publication_id: str,
        audience: typing.Optional[GetPublicationsPublicationIdPostsAudienceEnum] = None,
        content_tags: typing.Optional[typing.List[str]] = None,
        direction: typing.Optional[
            GetPublicationsPublicationIdPostsDirectionEnum
        ] = None,
        expand: typing.Optional[
            typing.List[GetPublicationsPublicationIdPostsExpandItemEnum]
        ] = None,
        limit: typing.Optional[int] = None,
        order_by: typing.Optional[GetPublicationsPublicationIdPostsOrderByEnum] = None,
        page: typing.Optional[int] = None,
        platform: typing.Optional[GetPublicationsPublicationIdPostsPlatformEnum] = None,
        status: typing.Optional[GetPublicationsPublicationIdPostsStatusEnum] = None,
    ) -> GetPublicationsPublicationIdPostsResponse:
        """
        Retrieve all posts belonging to a specific publication
        """
        _endpoint = f"/publications/{publication_id}/posts"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if audience is not None:
            _params["audience"] = audience
        if content_tags is not None:
            _params["content_tags[]"] = content_tags
        if direction is not None:
            _params["direction"] = direction
        if expand is not None:
            _params["expand[]"] = expand
        if limit is not None:
            _params["limit"] = limit
        if order_by is not None:
            _params["order_by"] = order_by
        if page is not None:
            _params["page"] = page
        if platform is not None:
            _params["platform"] = platform
        if status is not None:
            _params["status"] = status
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetPublicationsPublicationIdPostsResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def get_posts_post_id(
        self,
        *,
        publication_id: str,
        post_id: str,
        expand: typing.Optional[
            typing.List[GetPublicationsPublicationIdPostsPostIdExpandItemEnum]
        ] = None,
    ) -> GetPublicationsPublicationIdPostsPostIdResponse:
        """
        Retreive a single Post belonging to a specific publication
        """
        _endpoint = f"/publications/{publication_id}/posts/{post_id}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if expand is not None:
            _params["expand[]"] = expand
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetPublicationsPublicationIdPostsPostIdResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def get_publications_public_referral_program(
        self,
        *,
        publication_id: str,
        limit: typing.Optional[int] = None,
        page: typing.Optional[int] = None,
    ) -> GetPublicationsPublicationIdReferralProgramResponse:
        """
        Retrieve details about the publication's referral program, including milestones and rewards.
        """
        _endpoint = f"/publications/{publication_id}/referral_program"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if limit is not None:
            _params["limit"] = limit
        if page is not None:
            _params["page"] = page
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetPublicationsPublicationIdReferralProgramResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def get_publications_publication_id_segments(
        self,
        *,
        publication_id: str,
        direction: typing.Optional[
            GetPublicationsPublicationIdSegmentsDirectionEnum
        ] = None,
        limit: typing.Optional[int] = None,
        order_by: typing.Optional[
            GetPublicationsPublicationIdSegmentsOrderByEnum
        ] = None,
        page: typing.Optional[int] = None,
        status: typing.Optional[GetPublicationsPublicationIdSegmentsStatusEnum] = None,
        type: typing.Optional[GetPublicationsPublicationIdSegmentsTypeEnum] = None,
    ) -> GetPublicationsPublicationIdSegmentsResponse:
        """
        Retrieve information about all segments belonging to a specific publication
        """
        _endpoint = f"/publications/{publication_id}/segments"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if direction is not None:
            _params["direction"] = direction
        if limit is not None:
            _params["limit"] = limit
        if order_by is not None:
            _params["order_by"] = order_by
        if page is not None:
            _params["page"] = page
        if status is not None:
            _params["status"] = status
        if type is not None:
            _params["type"] = type
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetPublicationsPublicationIdSegmentsResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def get_publications_publication_id_segments_segment_id(
        self, *, publication_id: str, segment_id: str
    ) -> GetPublicationsPublicationIdSegmentsSegmentIdResponse:
        """
        Retrieve a single segment belonging to a specific publication
        """
        _endpoint = f"/publications/{publication_id}/segments/{segment_id}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetPublicationsPublicationIdSegmentsSegmentIdResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def get_publications_publication_id_segments_segment_id_results(
        self,
        *,
        publication_id: str,
        segment_id: str,
        limit: typing.Optional[int] = None,
        page: typing.Optional[int] = None,
    ) -> GetPublicationsPublicationIdSegmentsSegmentIdResultsResponse:
        """
        List the Subscriber Ids from the most recent calculation of a specific publication.
        """
        _endpoint = f"/publications/{publication_id}/segments/{segment_id}/results"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if limit is not None:
            _params["limit"] = limit
        if page is not None:
            _params["page"] = page
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetPublicationsPublicationIdSegmentsSegmentIdResultsResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def get_subscriptions(
        self,
        *,
        publication_id: str,
        direction: typing.Optional[
            GetPublicationsPublicationIdSubscriptionsDirectionEnum
        ] = None,
        email: typing.Optional[str] = None,
        expand: typing.Optional[
            typing.List[GetPublicationsPublicationIdSubscriptionsExpandItemEnum]
        ] = None,
        limit: typing.Optional[int] = None,
        order_by: typing.Optional[
            GetPublicationsPublicationIdSubscriptionsOrderByEnum
        ] = None,
        page: typing.Optional[int] = None,
        status: typing.Optional[
            GetPublicationsPublicationIdSubscriptionsStatusEnum
        ] = None,
        tier: typing.Optional[GetPublicationsPublicationIdSubscriptionsTierEnum] = None,
    ) -> GetPublicationsPublicationIdSubscriptionsResponse:
        """
        Retrieve all subscriptions belonging to a specific publication
        """
        _endpoint = f"/publications/{publication_id}/subscriptions"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if direction is not None:
            _params["direction"] = direction
        if email is not None:
            _params["email"] = email
        if expand is not None:
            _params["expand[]"] = expand
        if limit is not None:
            _params["limit"] = limit
        if order_by is not None:
            _params["order_by"] = order_by
        if page is not None:
            _params["page"] = page
        if status is not None:
            _params["status"] = status
        if tier is not None:
            _params["tier"] = tier
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetPublicationsPublicationIdSubscriptionsResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def get_subscriptions_email(
        self,
        *,
        publication_id: str,
        email: str,
        expand: typing.Optional[
            typing.List[
                GetPublicationsPublicationIdSubscriptionsByEmailEmailExpandItemEnum
            ]
        ] = None,
    ) -> GetPublicationsPublicationIdSubscriptionsByEmailEmailResponse:
        """
        Retrieve a single subscription belonging to a specific email address in a specific publication
        """
        _endpoint = f"/publications/{publication_id}/subscriptions/by_email/{email}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if expand is not None:
            _params["expand[]"] = expand
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetPublicationsPublicationIdSubscriptionsByEmailEmailResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def get_subscriptions_subscriber_id(
        self,
        *,
        publication_id: str,
        subscriber_id: str,
        expand: typing.Optional[
            typing.List[
                GetPublicationsPublicationIdSubscriptionsBySubscriberIdSubscriberIdExpandItemEnum
            ]
        ] = None,
    ) -> GetPublicationsPublicationIdSubscriptionsBySubscriberIdSubscriberIdResponse:
        """
        Retrieve a single subscription belonging to a specific subscriber in a specific publication
        """
        _endpoint = f"/publications/{publication_id}/subscriptions/by_subscriber_id/{subscriber_id}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if expand is not None:
            _params["expand[]"] = expand
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetPublicationsPublicationIdSubscriptionsBySubscriberIdSubscriberIdResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def get_subscriptions_subscription_id(
        self,
        *,
        publication_id: str,
        subscription_id: str,
        expand: typing.Optional[
            typing.List[
                GetPublicationsPublicationIdSubscriptionsSubscriptionIdExpandItemEnum
            ]
        ] = None,
    ) -> GetPublicationsPublicationIdSubscriptionsSubscriptionIdResponse:
        """
        Retrieve a single subscription belonging to a specific publication
        """
        _endpoint = f"/publications/{publication_id}/subscriptions/{subscription_id}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if expand is not None:
            _params["expand[]"] = expand
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetPublicationsPublicationIdSubscriptionsSubscriptionIdResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def patch_publications_publication_id_custom_fields_id(
        self,
        *,
        data: typing.Optional[PatchPublicationsPublicationIdCustomFieldsIdBody] = None,
        publication_id: str,
        id: str,
    ) -> PatchPublicationsPublicationIdCustomFieldsIdResponse:
        """
        Update a custom field on a publication
        """
        _endpoint = f"/publications/{publication_id}/custom_fields/{id}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.patch(
            _url, json=_json_data, **_authed_kwargs
        )

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=PatchPublicationsPublicationIdCustomFieldsIdResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def patch_subscriptions_bulk_update_status(
        self,
        *,
        data: typing.Optional[PatchPublicationsPublicationIdSubscriptionsBody] = None,
        publication_id: str,
    ) -> PatchPublicationsPublicationIdSubscriptionsResponse:
        """
        Bulk update subscriptions' Status value
        """
        _endpoint = f"/publications/{publication_id}/subscriptions"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.patch(
            _url, json=_json_data, **_authed_kwargs
        )

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=PatchPublicationsPublicationIdSubscriptionsResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def patch_subscriptions_bulk_actions_bulk_update(
        self,
        *,
        data: typing.Optional[
            PatchPublicationsPublicationIdSubscriptionsBulkActionsBody
        ] = None,
        publication_id: str,
    ) -> PatchPublicationsPublicationIdSubscriptionsBulkActionsResponse:
        """
        Bulk update subscriptions' field values (standard fields and custom fields)
        """
        _endpoint = f"/publications/{publication_id}/subscriptions/bulk_actions"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.patch(
            _url, json=_json_data, **_authed_kwargs
        )

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=PatchPublicationsPublicationIdSubscriptionsBulkActionsResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def method_1patch_subscriptions_subscription_id(
        self,
        *,
        data: PatchPublicationsPublicationIdSubscriptionsSubscriptionIdBody,
        publication_id: str,
        subscription_id: str,
    ) -> PatchPublicationsPublicationIdSubscriptionsSubscriptionIdResponse:
        """
        Update a subscriber
        """
        _endpoint = f"/publications/{publication_id}/subscriptions/{subscription_id}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.patch(
            _url, json=_json_data, **_authed_kwargs
        )

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=PatchPublicationsPublicationIdSubscriptionsSubscriptionIdResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def post_publications_publication_id_custom_fields(
        self,
        *,
        data: typing.Optional[PostPublicationsPublicationIdCustomFieldsBody] = None,
        publication_id: str,
    ) -> PostPublicationsPublicationIdCustomFieldsResponse:
        """
        Create a custom field on a publication, for use in subscriptions
        """
        _endpoint = f"/publications/{publication_id}/custom_fields"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=PostPublicationsPublicationIdCustomFieldsResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def post_subscriptions(
        self,
        *,
        data: PostPublicationsPublicationIdSubscriptionsBody,
        publication_id: str,
        sales: typing.Optional[str] = None,
    ) -> PostPublicationsPublicationIdSubscriptionsResponse:
        """
        Create new subscriptions for a publication.
        """
        _endpoint = f"/publications/{publication_id}/subscriptions"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if sales is not None:
            _params["sales"] = sales
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=PostPublicationsPublicationIdSubscriptionsResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def put_publications_publication_id_custom_fields_id(
        self,
        *,
        data: typing.Optional[PutPublicationsPublicationIdCustomFieldsIdBody] = None,
        publication_id: str,
        id: str,
    ) -> PutPublicationsPublicationIdCustomFieldsIdResponse:
        """
        Update a custom field on a publication
        """
        _endpoint = f"/publications/{publication_id}/custom_fields/{id}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.put(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=PutPublicationsPublicationIdCustomFieldsIdResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def put_subscriptions_bulk_update_status(
        self,
        *,
        data: typing.Optional[PutPublicationsPublicationIdSubscriptionsBody] = None,
        publication_id: str,
    ) -> PutPublicationsPublicationIdSubscriptionsResponse:
        """
        Bulk update subscriptions' Status value
        """
        _endpoint = f"/publications/{publication_id}/subscriptions"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.put(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=PutPublicationsPublicationIdSubscriptionsResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def put_subscriptions_bulk_actions_bulk_update(
        self,
        *,
        data: typing.Optional[
            PutPublicationsPublicationIdSubscriptionsBulkActionsBody
        ] = None,
        publication_id: str,
    ) -> PutPublicationsPublicationIdSubscriptionsBulkActionsResponse:
        """
        Bulk update subscriptions' field values (standard fields and custom fields)
        """
        _endpoint = f"/publications/{publication_id}/subscriptions/bulk_actions"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.put(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=PutPublicationsPublicationIdSubscriptionsBulkActionsResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    async def put_subscriptions_subscription_id(
        self,
        *,
        data: PutPublicationsPublicationIdSubscriptionsSubscriptionIdBody,
        publication_id: str,
        subscription_id: str,
    ) -> PutPublicationsPublicationIdSubscriptionsSubscriptionIdResponse:
        """
        Update a subscriber
        """
        _endpoint = f"/publications/{publication_id}/subscriptions/{subscription_id}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = await self.session.put(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=PutPublicationsPublicationIdSubscriptionsSubscriptionIdResponse,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=429,
                expected_type=Error,
            ),
            sdk_response.ResponseCaster(
                status_code=500,
                expected_type=Error,
            ),
        ]

        _caster = [c for c in _casters if c.match_code(_raw_response.status_code)]
        if len(_caster) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )

        _response_data = _caster[0].cast_response(_raw_response)

        if _raw_response.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data
