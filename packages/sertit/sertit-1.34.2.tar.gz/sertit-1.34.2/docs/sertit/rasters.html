<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"/>
<meta name="generator" content="pdoc 0.10.0"/>
<title>sertit.rasters API documentation</title>
<meta name="description" content="Raster tools â€¦"/>
<link rel="preload stylesheet" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/darcula.min.css"
crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100%;padding:3em 4em;border-left:1px solid #ddd;overflow-x:hidden}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}table{display:block;overflow-x:auto;word-break:keep-all;border-collapse:separate;border-spacing:0}th{background-color:#c4d5e780;padding:5px;border-bottom:0.1px solid gray;border-right:0.1px solid gray;border-top:0.1px solid gray}td,th{margin:0}td{white-space:nowrap;border-bottom:0.1px solid gray;border-right:0.1px solid gray}td:empty{background-color:#ececec}th:nth-child(1){border-left:0.1px solid gray}td:nth-child(1){border-left:0.1px solid gray;border-right:0.1px solid gray}th:nth-child(1),td:nth-child(1){background-color:#c4d5e7;position:-webkit-sticky;position:sticky;left:0}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML"
integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"
integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sertit.rasters</code></h1>
</header>
<section id="section-intro">
<p>Raster tools</p>
<p>You can use this only if you have installed sertit[full] or sertit[rasters]</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# Copyright 2021, SERTIT-ICube - France, https://sertit.unistra.fr/
# This file is part of sertit-utils project
#     https://github.com/sertit/sertit-utils
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
&#34;&#34;&#34;
Raster tools

You can use this only if you have installed sertit[full] or sertit[rasters]
&#34;&#34;&#34;
import logging
from functools import wraps
from pathlib import Path
from typing import Any, Callable, Optional, Union

import numpy as np
import xarray
from cloudpathlib import CloudPath
from rioxarray.exceptions import MissingCRS

from sertit.logs import SU_NAME
from sertit.rasters_rio import MAX_CORES, PATH_ARR_DS, path_arr_dst

try:
    import geopandas as gpd
    import rasterio
    import rioxarray
    import xarray as xr
    from rasterio import features
    from rasterio.enums import Resampling
    from shapely.geometry import Polygon
except ModuleNotFoundError as ex:
    raise ModuleNotFoundError(
        &#34;Please install &#39;rioxarray&#39; and &#39;geopandas&#39; to use the &#39;rasters&#39; package.&#34;
    ) from ex

from sertit import files, rasters_rio, vectors

MAX_CORES = MAX_CORES
PATH_XARR_DS = Union[str, xr.DataArray, xr.Dataset, rasterio.DatasetReader]
LOGGER = logging.getLogger(SU_NAME)

&#34;&#34;&#34;
Types:

- Path
- rasterio Dataset
- `xarray.DataArray` and `xarray.Dataset`
&#34;&#34;&#34;  # fmt:skip

XDS_TYPE = Union[xr.Dataset, xr.DataArray]
&#34;&#34;&#34;
Xarray types: xr.Dataset and xr.DataArray
&#34;&#34;&#34;  # fmt:skip


def path_xarr_dst(function: Callable) -&gt; Callable:
    &#34;&#34;&#34;
    Path, `xarray` or dataset decorator. Allows a function to ingest:

    - a path
    - a `xarray`
    - a `rasterio` dataset

    ```python
    &gt;&gt;&gt; # Create mock function
    &gt;&gt;&gt; @path_or_dst
    &gt;&gt;&gt; def fct(dst):
    &gt;&gt;&gt;     read(dst)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Test the two ways
    &gt;&gt;&gt; read1 = fct(&#34;path\\to\\raster.tif&#34;)
    &gt;&gt;&gt; with rasterio.open(&#34;path\\to\\raster.tif&#34;) as dst:
    &gt;&gt;&gt;     read2 = fct(dst)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Test
    &gt;&gt;&gt; read1 == read2
    True
    ```
    Args:
        function (Callable): Function to decorate

    Returns:
        Callable: decorated function
    &#34;&#34;&#34;

    @wraps(function)
    def path_or_xarr_or_dst_wrapper(path_or_ds: PATH_XARR_DS, *args, **kwargs) -&gt; Any:
        &#34;&#34;&#34;
        Path or dataset wrapper
        Args:
            path_or_ds (PATH_XARR_DS): Raster path or its dataset
            *args: args
            **kwargs: kwargs

        Returns:
            Any: regular output
        &#34;&#34;&#34;
        if isinstance(path_or_ds, xr.DataArray):
            out = function(path_or_ds, *args, **kwargs)
        elif isinstance(path_or_ds, xr.Dataset):
            # Try on the whole dataset
            try:
                out = function(path_or_ds, *args, **kwargs)
            except Exception:
                # Try on every dataarray
                try:
                    xds_dict = {}
                    convert_to_xdataset = False
                    for var in path_or_ds.data_vars:
                        xds_dict[var] = function(path_or_ds[var], *args, **kwargs)
                        if isinstance(xds_dict[var], xr.DataArray):
                            convert_to_xdataset = True

                    # Convert in dataset if we have dataarrays, else keep the dict
                    if convert_to_xdataset:
                        xds = xr.Dataset(xds_dict)
                    else:
                        xds = xds_dict
                    return xds
                except Exception as ex:
                    raise TypeError(&#34;Function not available for xarray.Dataset&#34;) from ex
        else:
            # Get name
            if isinstance(path_or_ds, (str, Path, CloudPath)):
                name = str(path_or_ds)
                path_or_ds = str(path_or_ds)
            else:
                name = path_or_ds.name

            with rioxarray.open_rasterio(
                path_or_ds, masked=True, default_name=name, chunks=True
            ) as xds:
                out = function(xds, *args, **kwargs)
        return out

    return path_or_xarr_or_dst_wrapper


def to_np(xds: xarray.DataArray, dtype: Any = None) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Convert the `xarray` to a `np.ndarray` with the correct nodata encoded.

    This is particularly useful when reading with `masked=True`.

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\mask.tif&#34;  # Classified raster in np.uint8 with nodata = 255
    &gt;&gt;&gt; # We read with masked=True so the data is converted to float
    &gt;&gt;&gt; xds = read(raster_path)
    &lt;xarray.DataArray &#39;path/to/mask.tif&#39; (band: 1, y: 322, x: 464)&gt;
    [149408 values with dtype=float64]
    Coordinates:
      * band         (band) int32 1
      * y            (y) float64 4.798e+06 4.798e+06 ... 4.788e+06 4.788e+06
      * x            (x) float64 5.411e+05 5.411e+05 ... 5.549e+05 5.55e+05
        spatial_ref  int32 0
    &gt;&gt;&gt; to_np(xds)  # Getting back np.uint8 and encoded nodata
    array([[[255, 255, 255, ..., 255, 255, 255],
        [255, 255, 255, ..., 255, 255, 255],
        [255, 255, 255, ..., 255, 255, 255],
        ...,
        [255, 255, 255, ...,   1, 255, 255],
        [255, 255, 255, ...,   1, 255, 255],
        [255, 255, 255, ...,   1, 255, 255]]], dtype=uint8)

    True
    ```
    Args:
        xds (xarray.DataArray): `xarray.DataArray` to convert
        dtype (Any): Dtype to convert to. If None, using the origin dtype if existing or its current dtype.

    Returns:

    &#34;&#34;&#34;
    # Manage dtype
    if not dtype:
        dtype = xds.encoding.get(&#34;dtype&#34;, xds.dtype)

    # Manage nodata
    if xds.rio.encoded_nodata is not None:
        xds_fill = xds.fillna(xds.rio.encoded_nodata)
    else:
        xds_fill = xds

    # Cast to wanted dtype
    arr = xds_fill.data.astype(dtype)

    return arr


def get_nodata_mask(xds: XDS_TYPE) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Get nodata mask from a xarray.

    ```python
    &gt;&gt;&gt; diag_arr = xr.DataArray(data=np.diag([1, 2, 3]))
    &gt;&gt;&gt; diag_arr.rio.write_nodata(0, inplace=True)
    &lt;xarray.DataArray (dim_0: 3, dim_1: 3)&gt;
    array([[1, 0, 0],
           [0, 2, 0],
           [0, 0, 3]])
    Dimensions without coordinates: dim_0, dim_1

    &gt;&gt;&gt; get_nodata_mask(diag_arr)
    array([[1, 0, 0],
           [0, 1, 0],
           [0, 0, 1]], dtype=uint8)
    ```

    Args:
        xds (XDS_TYPE): Array to evaluate

    Returns:
        np.ndarray: Pixelwise nodata array

    &#34;&#34;&#34;

    nodata = xds.rio.nodata

    try:
        is_nan = np.isnan(nodata)
    except TypeError:
        is_nan = False

    if is_nan:
        nodata_pos = np.isnan(xds.data)
    else:
        nodata_pos = xds.data == nodata

    return np.where(nodata_pos, 0, 1).astype(np.uint8)


@path_xarr_dst
def _vectorize(
    xds: PATH_XARR_DS,
    values: Union[None, int, list] = None,
    keep_values: bool = True,
    dissolve: bool = False,
    get_nodata: bool = False,
    default_nodata: int = 0,
) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Vectorize a xarray, both to get classes or nodata.

    If dissolved is False, it returns a GeoDataFrame with a GeoSeries per cluster of pixel value,
    with the value as an attribute. Else it returns a GeoDataFrame with a unique polygon.

    .. WARNING::
        - If `get_nodata` is set to False:
            - Your data is casted by force into np.uint8, so be sure that your data is classified.
            - This could take a while as the computing time directly depends on the number of polygons to vectorize.
                Please be careful.
    Else:
        - You will get a classified polygon with data (value=0)/nodata pixels. To

    Args:
        xds (PATH_XARR_DS): Path to the raster or a rasterio dataset or a xarray
        values (Union[None, int, list]): Get only the polygons concerning this/these particular values
        keep_values (bool): Keep the passed values. If False, discard them and keep the others.
        dissolve (bool): Dissolve all the polygons into one unique. Only works if values are given.
        get_nodata (bool): Get nodata vector (raster values are set to 0, nodata values are the other ones)
        default_nodata (int): Default values for nodata in case of non existing in file
    Returns:
        gpd.GeoDataFrame: Vector with the raster values (if dissolve is not set)
    &#34;&#34;&#34;
    # Manage nodata value
    has_nodata = xds.rio.encoded_nodata is not None
    nodata = xds.rio.encoded_nodata if has_nodata else default_nodata

    if get_nodata:
        data = get_nodata_mask(xds)
        nodata_arr = None
    else:
        data = to_np(xds, dtype=np.uint8)
        # Manage values
        if values is not None:
            if not isinstance(values, list):
                values = [values]

            # If we want a dissolved vector, just set 1instead of real values
            arr_vals = 1 if dissolve else data
            if keep_values:
                true = arr_vals
                false = nodata
            else:
                true = nodata
                false = arr_vals

            data = np.where(np.isin(data, values), true, false).astype(np.uint8)

        if data.dtype != np.uint8:
            raise TypeError(&#34;Your data should be classified (np.uint8).&#34;)

        nodata_arr = rasters_rio.get_nodata_mask(
            data, has_nodata=False, default_nodata=nodata
        )

    # WARNING: features.shapes do NOT accept dask arrays !
    if not isinstance(data, (np.ndarray, np.ma.masked_array)):
        data = data.compute()
    if nodata_arr is not None and not isinstance(
        nodata_arr, (np.ndarray, np.ma.masked_array)
    ):
        nodata_arr = nodata_arr.compute()

    # Get shapes (on array or on mask to get nodata vector)
    shapes = features.shapes(data, mask=nodata_arr, transform=xds.rio.transform())

    # Convert to geodataframe
    gdf = vectors.shapes_to_gdf(shapes, xds.rio.crs)

    try:
        from shapely.validation import make_valid

        # Discard self-intersection and null geometries
        gdf.geometry = gdf.geometry.apply(make_valid)
    except ImportError:
        import shapely

        LOGGER.warning(
            f&#34;make_valid not available in shapely (version {shapely.__version__} &lt; 1.8). &#34;
            f&#34;The obtained vector may be broken !&#34;
        )
        pass

    # Dissolve if needed
    if dissolve:
        gdf = gpd.GeoDataFrame(geometry=gdf.geometry, crs=gdf.crs).dissolve()

    return gdf


@path_xarr_dst
def vectorize(
    xds: PATH_XARR_DS,
    values: Union[None, int, list] = None,
    keep_values: bool = True,
    dissolve: bool = False,
    default_nodata: int = 0,
) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Vectorize a `xarray` to get the class vectors.

    If dissolved is False, it returns a GeoDataFrame with a GeoSeries per cluster of pixel value,
    with the value as an attribute. Else it returns a GeoDataFrame with a unique polygon.

    .. WARNING::
        - Your data is casted by force into np.uint8, so be sure that your data is classified.
        - This could take a while as the computing time directly depends on the number of polygons to vectorize.
            Please be careful.

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\raster.tif&#34;
    &gt;&gt;&gt; vec1 = vectorize(raster_path)
    &gt;&gt;&gt; # or
    &gt;&gt;&gt; with rasterio.open(raster_path) as dst:
    &gt;&gt;&gt;     vec2 = vectorize(dst)
    &gt;&gt;&gt; vec1 == vec2
    True
    ```

    Args:
        xds (PATH_XARR_DS): Path to the raster or a rasterio dataset or a xarray
        values (Union[None, int, list]): Get only the polygons concerning this/these particular values
        keep_values (bool): Keep the passed values. If False, discard them and keep the others.
        dissolve (bool): Dissolve all the polygons into one unique. Only works if values are given.
        default_nodata (int): Default values for nodata in case of non existing in file
    Returns:
        gpd.GeoDataFrame: Classes Vector
    &#34;&#34;&#34;
    return _vectorize(
        xds,
        values=values,
        keep_values=keep_values,
        dissolve=dissolve,
        get_nodata=False,
        default_nodata=default_nodata,
    )


@path_xarr_dst
def get_valid_vector(xds: PATH_XARR_DS, default_nodata: int = 0) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Get the valid data of a raster as a vector.

    Pay attention that every nodata pixel will appear too.
    If you want only the footprint of the raster, please use `get_footprint`.

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\raster.tif&#34;
    &gt;&gt;&gt; nodata1 = get_nodata_vec(raster_path)
    &gt;&gt;&gt; # or
    &gt;&gt;&gt; with rasterio.open(raster_path) as dst:
    &gt;&gt;&gt;     nodata2 = get_nodata_vec(dst)
    &gt;&gt;&gt; nodata1 == nodata2
    True
    ```

    Args:
        xds (PATH_XARR_DS): Path to the raster or a rasterio dataset or a xarray
        default_nodata (int): Default values for nodata in case of non existing in file
    Returns:
        gpd.GeoDataFrame: Nodata Vector

    &#34;&#34;&#34;
    nodata = _vectorize(
        xds, values=None, get_nodata=True, default_nodata=default_nodata
    )
    return nodata[
        nodata.raster_val != 0
    ]  # 0 is the values of not nodata put there by rasterio


@path_xarr_dst
def get_nodata_vector(dst: PATH_ARR_DS, default_nodata: int = 0) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Get the nodata vector of a raster as a vector.

    Pay attention that every nodata pixel will appear too.
    If you want only the footprint of the raster, please use `get_footprint`.

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\raster.tif&#34;  # Classified raster, with no data set to 255
    &gt;&gt;&gt; nodata1 = get_nodata_vec(raster_path)
    &gt;&gt;&gt; # or
    &gt;&gt;&gt; with rasterio.open(raster_path) as dst:
    &gt;&gt;&gt;     nodata2 = get_nodata_vec(dst)
    &gt;&gt;&gt; nodata1 == nodata2
    True
    ```

    Args:
        dst (PATH_ARR_DS): Path to the raster, its dataset, its `xarray` or a tuple containing its array and metadata
        default_nodata (int): Default values for nodata in case of non existing in file
    Returns:
        gpd.GeoDataFrame: Nodata Vector

    &#34;&#34;&#34;
    nodata = _vectorize(
        dst, values=None, get_nodata=True, default_nodata=default_nodata
    )
    return nodata[nodata.raster_val == 0]


@path_xarr_dst
def mask(
    xds: PATH_XARR_DS,
    shapes: Union[gpd.GeoDataFrame, Polygon, list],
    nodata: Optional[int] = None,
    **kwargs,
) -&gt; XDS_TYPE:
    &#34;&#34;&#34;
    Masking a dataset:
    setting nodata outside of the given shapes, but without cropping the raster to the shapes extent.

    The original nodata is kept and completed with the nodata provided by the shapes.

    Overload of rasterio mask function in order to create a `xarray`.

    The `mask` function docs can be seen [here](https://rasterio.readthedocs.io/en/latest/api/rasterio.mask.html).
    It basically masks a raster with a vector mask, with the possibility to crop the raster to the vector&#39;s extent.

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\raster.tif&#34;
    &gt;&gt;&gt; shape_path = &#34;path\\to\\shapes.geojson&#34;  # Any vector that geopandas can read
    &gt;&gt;&gt; shapes = gpd.read_file(shape_path)
    &gt;&gt;&gt; mask1 = mask(raster_path, shapes)
    &gt;&gt;&gt; # or
    &gt;&gt;&gt; with rasterio.open(raster_path) as dst:
    &gt;&gt;&gt;     mask2 = mask(dst, shapes)
    &gt;&gt;&gt; mask1 == mask2
    True
    ```

    Args:
        xds (PATH_XARR_DS): Path to the raster or a rasterio dataset or a xarray
        shapes (Union[gpd.GeoDataFrame, Polygon, list]): Shapes with the same CRS as the dataset
            (except if a `GeoDataFrame` is passed, in which case it will automatically be converted)
        nodata (int): Nodata value. If not set, uses the ds.nodata. If doesnt exist, set to 0.
        **kwargs: Other rasterio.mask options

    Returns:
         XDS_TYPE: Masked array as a xarray
    &#34;&#34;&#34;
    # Use classic option
    arr, meta = rasters_rio.mask(xds, shapes=shapes, nodata=nodata, **kwargs)

    masked_xds = xds.copy(data=arr)

    if nodata:
        masked_xds = set_nodata(masked_xds, nodata)

    # Convert back to xarray
    return masked_xds


@path_xarr_dst
def paint(
    xds: PATH_XARR_DS,
    shapes: Union[gpd.GeoDataFrame, Polygon, list],
    value: int,
    invert: bool = False,
    **kwargs,
) -&gt; XDS_TYPE:
    &#34;&#34;&#34;
    Painting a dataset: setting values inside the given shapes. To set outside the shape, set invert=True.
    Pay attention that this behavior is the opposite of the `rasterio.mask` function.

    The original nodata is kept.
    This means if your shapes intersects the original nodata,
    the value of the pixel will be set to nodata rather than to the wanted value.

    Overload of rasterio mask function in order to create a `xarray`.
    The `mask` function docs can be seen [here](https://rasterio.readthedocs.io/en/latest/api/rasterio.mask.html).

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\raster.tif&#34;
    &gt;&gt;&gt; shape_path = &#34;path\\to\\shapes.geojson&#34;  # Any vector that geopandas can read
    &gt;&gt;&gt; shapes = gpd.read_file(shape_path)
    &gt;&gt;&gt; paint1 = paint(raster_path, shapes, value=100)
    &gt;&gt;&gt; # or
    &gt;&gt;&gt; with rasterio.open(raster_path) as dst:
    &gt;&gt;&gt;     paint2 = paint(dst, shapes, value=100)
    &gt;&gt;&gt; paint1 == paint2
    True
    ```

    Args:
        xds (PATH_XARR_DS): Path to the raster or a rasterio dataset or a xarray
        shapes (Union[gpd.GeoDataFrame, Polygon, list]): Shapes with the same CRS as the dataset
            (except if a `GeoDataFrame` is passed, in which case it will automatically be converted)
        value (int): Value to set on the shapes.
        invert (bool): If invert is True, set value outside the shapes.
        **kwargs: Other rasterio.mask options

    Returns:
         XDS_TYPE: Painted array as a xarray
    &#34;&#34;&#34;
    # Fill na values in order to not interfere with the mask function
    if xds.rio.encoded_nodata is not None:
        xds_fill = xds.fillna(xds.rio.encoded_nodata)
    elif xds.rio.nodata is not None:
        xds_fill = xds.fillna(xds.rio.nodata)
    else:
        xds_fill = xds

    # Use classic option
    arr, meta = rasters_rio.mask(
        xds_fill, shapes=shapes, nodata=value, invert=not invert, **kwargs
    )

    # Create and fill na values created by the mask to the wanted value
    painted_xds = xds.copy(data=arr)
    painted_xds = painted_xds.fillna(value)

    # Set back nodata to keep the original nodata
    if xds.rio.encoded_nodata is not None:
        painted_xds = set_nodata(painted_xds, xds.rio.encoded_nodata)

    # Convert back to xarray
    return painted_xds


@path_xarr_dst
def crop(
    xds: PATH_XARR_DS,
    shapes: Union[gpd.GeoDataFrame, Polygon, list],
    nodata: Optional[int] = None,
    **kwargs,
) -&gt; (np.ma.masked_array, dict):
    &#34;&#34;&#34;
    Cropping a dataset:
    setting nodata outside of the given shapes AND cropping the raster to the shapes extent.

    Overload of [`rioxarray`
    clip](https://corteva.github.io/rioxarray/stable/rioxarray.html#rioxarray.raster_array.RasterArray.clip)
    function in order to create a masked_array.

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\raster.tif&#34;
    &gt;&gt;&gt; shape_path = &#34;path\\to\\shapes.geojson&#34;  # Any vector that geopandas can read
    &gt;&gt;&gt; shapes = gpd.read_file(shape_path)
    &gt;&gt;&gt; xds2 = crop(raster_path, shapes)
    &gt;&gt;&gt; # or
    &gt;&gt;&gt; with rasterio.open(raster_path) as dst:
    &gt;&gt;&gt;     xds2 = crop(dst, shapes)
    &gt;&gt;&gt; xds1 == xds2
    True
    ```

    Args:
        xds (PATH_XARR_DS): Path to the raster or a rasterio dataset or a xarray
        shapes (Union[gpd.GeoDataFrame, Polygon, list]): Shapes with the same CRS as the dataset
            (except if a `GeoDataFrame` is passed, in which case it will automatically be converted)
        nodata (int): Nodata value. If not set, uses the ds.nodata. If doesnt exist, set to 0.
        **kwargs: Other rioxarray.clip options

    Returns:
         XDS_TYPE: Cropped array as a xarray
    &#34;&#34;&#34;
    if nodata:
        xds_new = xds.rio.write_nodata(nodata)
    else:
        xds_new = xds

    if isinstance(shapes, (gpd.GeoDataFrame, gpd.GeoSeries)):
        shapes = shapes.to_crs(xds.rio.crs).geometry

    if &#34;from_disk&#34; not in kwargs:
        kwargs[&#34;from_disk&#34;] = True  # WAY FASTER

    return xds_new.rio.clip(shapes, **kwargs)


@path_arr_dst
def read(
    dst: PATH_ARR_DS,
    resolution: Union[tuple, list, float] = None,
    size: Union[tuple, list] = None,
    resampling: Resampling = Resampling.nearest,
    masked: bool = True,
    indexes: Union[int, list] = None,
    chunks: Union[int, tuple, dict] = None,
    **kwargs,
) -&gt; XDS_TYPE:
    &#34;&#34;&#34;
    Read a raster dataset from a :

    - `xarray` (compatibility issues)
    - `rasterio.Dataset`
    - `rasterio` opened data (array, metadata)
    - a path.

    The resolution can be provided (in dataset unit) as:

    - a tuple or a list of (X, Y) resolutions
    - a float, in which case X resolution = Y resolution
    - None, in which case the dataset resolution will be used

    Uses [rioxarray.open_rasterio](https://corteva.github.io/rioxarray/stable/rioxarray.html#rioxarray-open-rasterio).
    For Dask usage, you can look at the
    [rioxarray tutorial](https://corteva.github.io/rioxarray/stable/examples/dask_read_write.html).

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\raster.tif&#34;
    &gt;&gt;&gt; xds1 = read(raster_path)
    &gt;&gt;&gt; # or
    &gt;&gt;&gt; with rasterio.open(raster_path) as dst:
    &gt;&gt;&gt;    xds2 = read(dst)
    &gt;&gt;&gt; xds1 == xds2
    True
    ```

    Args:
        dst (PATH_ARR_DS): Path to the raster or a rasterio dataset or a xarray
        resolution (Union[tuple, list, float]): Resolution of the wanted band, in dataset resolution unit (X, Y)
        size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        resampling (Resampling): Resampling method
        masked (bool): Get a masked array
        indexes (Union[int, list]): Indexes to load. Load the whole array if None.
        chunks (int, tuple or dict): Chunk sizes along each dimension, e.g., 5, (5, 5) or {&#39;x&#39;: 5, &#39;y&#39;: 5}.
            If chunks is provided, it used to load the new DataArray into a dask array.
            Chunks can also be set to True or &#34;auto&#34; to choose sensible chunk sizes
            according to dask.config.get(&#34;array.chunk-size&#34;).
        **kwargs: Optional keyword arguments to pass into rioxarray.open_rasterio().
    Returns:
        Union[XDS_TYPE]: Masked xarray corresponding to the raster data and its meta data

    &#34;&#34;&#34;
    # Get new height and width
    new_height, new_width = rasters_rio.get_new_shape(dst, resolution, size)

    # Read data (and load it to discard lock)
    with xarray.set_options(keep_attrs=True):
        with rioxarray.open_rasterio(
            dst, default_name=files.get_filename(dst.name), chunks=chunks, **kwargs
        ) as xda:
            orig_dtype = xda.dtype
            if indexes:
                if not isinstance(indexes, list):
                    indexes = [indexes]

                # Open only wanted bands
                xda = xda[np.isin(xda.band, indexes)]

                try:
                    # Set new long name: Bands nb are idx + 1
                    xda.long_name = tuple(
                        name for i, name in enumerate(xda.long_name) if i + 1 in indexes
                    )
                except AttributeError:
                    pass

            # Manage resampling
            if new_height != dst.height or new_width != dst.width:
                factor_h = dst.height / new_height
                factor_w = dst.width / new_width
                if factor_h.is_integer() and factor_w.is_integer():
                    xda = xda.coarsen(x=int(factor_w), y=int(factor_h)).mean()
                else:
                    xda = xda.rio.reproject(
                        xda.rio.crs,
                        shape=(new_height, new_width),
                        resampling=resampling,
                    )

            if masked:
                # Set nodata not in opening due to some performance issues
                xda = set_nodata(xda, dst.meta[&#34;nodata&#34;])

            # Set original dtype
            xda.encoding[&#34;dtype&#34;] = orig_dtype

    return xda


@path_xarr_dst
def write(xds: XDS_TYPE, path: Union[str, CloudPath, Path], **kwargs) -&gt; None:
    &#34;&#34;&#34;
    Write raster to disk.
    (encapsulation of `rasterio`&#39;s function, because for now `rioxarray` to_raster doesn&#39;t work as expected)

    Metadata will be created with the `xarray` metadata (ie. width, height, count, type...)
    The driver is `GTiff` by default, and no nodata value is provided.
    The file will be compressed if the raster is a mask (saved as uint8).

    If not overwritten, sets the nodata according to `dtype`:

    - uint8: 255
    - int8: -128
    - uint16, uint32, int32, int64, uint64: 65535
    - int16, float32, float64, float128, float: -9999

    Compress with `LZW` option by default. To disable it, add the `compress=None` parameter.

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\raster.tif&#34;
    &gt;&gt;&gt; raster_out = &#34;path\\to\\out.tif&#34;

    &gt;&gt;&gt; # Read raster
    &gt;&gt;&gt; xds = read(raster_path)

    &gt;&gt;&gt; # Rewrite it
    &gt;&gt;&gt; write(xds, raster_out)
    ```

    Args:
        xds (XDS_TYPE): Path to the raster or a rasterio dataset or a xarray
        path (Union[str, CloudPath, Path]): Path where to save it (directories should be existing)
        **kwargs: Overloading metadata, ie `nodata=255` or `dtype=np.uint8`
    &#34;&#34;&#34;
    if &#34;nodata&#34; in kwargs:
        xds.encoding[&#34;_FillValue&#34;] = kwargs.pop(&#34;nodata&#34;)
    else:
        # Manage default nodata in function of dtype (default, for float = -9999)
        if &#34;dtype&#34; in kwargs:
            dtype = kwargs[&#34;dtype&#34;]
        else:
            dtype = xds.dtype

        # Convert to numpy dtype
        if isinstance(dtype, str):
            dtype = getattr(np, dtype)

        if dtype == np.uint8:
            xds.encoding[&#34;_FillValue&#34;] = 255
        elif dtype == np.int8:
            xds.encoding[&#34;_FillValue&#34;] = -128
        elif dtype in [np.uint16, np.uint32, np.int32, np.int64, np.uint64, int]:
            xds.encoding[&#34;_FillValue&#34;] = 65535
        elif dtype in [np.int16, np.float32, np.float64, float]:
            xds.encoding[&#34;_FillValue&#34;] = -9999
        else:
            raise ValueError(
                f&#34;Invalid dtype: {dtype}, should be convertible to numpy dtypes&#34;
            )

    # Default compression to LZW
    if &#34;compress&#34; not in kwargs:
        kwargs[&#34;compress&#34;] = &#34;lzw&#34;

    # WORKAROUND: Pop _FillValue attribute
    if &#34;_FillValue&#34; in xds.attrs:
        xds.attrs.pop(&#34;_FillValue&#34;)

    # Bigtiff if needed
    if xds.data.size * xds.data.itemsize / 1024 / 1024 / 1024 &gt; 4:
        bigtiff = &#34;YES&#34;
    else:
        bigtiff = &#34;IF_NEEDED&#34;

    # Manage tiles
    if &#34;tiled&#34; not in kwargs:
        kwargs[&#34;tiled&#34;] = True

    # Force GTiff
    kwargs[&#34;driver&#34;] = &#34;GTiff&#34;

    # Write on disk
    xds.rio.to_raster(str(path), BIGTIFF=bigtiff, NUM_THREADS=MAX_CORES, **kwargs)


def collocate(
    master_xds: XDS_TYPE,
    slave_xds: XDS_TYPE,
    resampling: Resampling = Resampling.nearest,
) -&gt; XDS_TYPE:
    &#34;&#34;&#34;
    Collocate two georeferenced arrays:
    forces the *slave* raster to be exactly georeferenced onto the *master* raster by reprojection.

    Use it like `OTB SuperImpose`.

    ```python
    &gt;&gt;&gt; master_path = &#34;path\\to\\master.tif&#34;
    &gt;&gt;&gt; slave_path = &#34;path\\to\\slave.tif&#34;
    &gt;&gt;&gt; col_path = &#34;path\\to\\collocated.tif&#34;

    &gt;&gt;&gt; # Collocate the slave to the master
    &gt;&gt;&gt; col_xds = collocate(read(master_path), read(slave_path), Resampling.bilinear)

    &gt;&gt;&gt; # Write it
    &gt;&gt;&gt; write(col_xds, col_path)
    ```

    Args:
        master_xds (XDS_TYPE): Master xarray
        slave_xds (XDS_TYPE): Slave xarray
        resampling (Resampling): Resampling method

    Returns:
        XDS_TYPE: Collocated xarray

    &#34;&#34;&#34;
    collocated_xds = slave_xds.rio.reproject_match(master_xds, resampling=resampling)
    collocated_xds = collocated_xds.assign_coords(
        {
            &#34;x&#34;: master_xds.x,
            &#34;y&#34;: master_xds.y,
        }
    )  # Bug for now, tiny difference in coords
    return collocated_xds


@path_xarr_dst
def sieve(
    xds: PATH_XARR_DS, sieve_thresh: int, connectivity: int = 4, dtype=np.uint8
) -&gt; XDS_TYPE:
    &#34;&#34;&#34;
    Sieving, overloads rasterio function with raster shaped like (1, h, w).

    .. WARNING::
        Your data is casted by force into `np.uint8`, so be sure that your data is classified.

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\raster.tif&#34;  # classified raster

    &gt;&gt;&gt; # Rewrite it
    &gt;&gt;&gt; sieved_xds = sieve(raster_path, sieve_thresh=20)

    &gt;&gt;&gt; # Write it
    &gt;&gt;&gt; raster_out = &#34;path\\to\\raster_sieved.tif&#34;
    &gt;&gt;&gt; write(sieved_xds, raster_out)
    ```

    Args:
        xds (PATH_XARR_DS): Path to the raster or a rasterio dataset or a xarray
        sieve_thresh (int): Sieving threshold in pixels
        connectivity (int): Connectivity, either 4 or 8
        dtype: Dtype of the xarray
            (if nodata is set, the xds.dtype is float whereas the values are meant to be ie in np.uint8)

    Returns:
        (XDS_TYPE): Sieved xarray
    &#34;&#34;&#34;
    assert connectivity in [4, 8]

    # Use this trick to make the sieve work
    data = np.squeeze(to_np(xds, dtype))

    # Sieve
    try:
        sieved_arr = features.sieve(data, size=sieve_thresh, connectivity=connectivity)
    except TypeError:
        # Manage dask arrays that fails with rasterio sieve
        sieved_arr = features.sieve(
            data.compute(), size=sieve_thresh, connectivity=connectivity
        )

    # Create back the xarray
    sieved_arr = np.expand_dims(sieved_arr.astype(xds.dtype), axis=0)
    sieved_xds = xds.copy(data=sieved_arr)

    # Set back nodata
    if xds.rio.encoded_nodata is not None:
        sieved_xds = set_nodata(sieved_xds, xds.rio.encoded_nodata)

    return sieved_xds


def get_dim_img_path(
    dim_path: Union[str, CloudPath, Path], img_name: str = &#34;*&#34;
) -&gt; Union[CloudPath, Path]:
    &#34;&#34;&#34;
    Get the image path from a *BEAM-DIMAP* data.

    A *BEAM-DIMAP* file cannot be opened by rasterio, although its .img file can.

    ```python
    &gt;&gt;&gt; dim_path = &#34;path\\to\\dimap.dim&#34;  # BEAM-DIMAP image
    &gt;&gt;&gt; img_path = get_dim_img_path(dim_path)

    &gt;&gt;&gt; # Read raster
    &gt;&gt;&gt; raster, meta = read(img_path)
    ```

    Args:
        dim_path (Union[str, CloudPath, Path]): DIM path (.dim or .data)
        img_name (str): .img file name (or regex), in case there are multiple .img files (ie. for S3 data)

    Returns:
        Union[CloudPath, Path]: .img file
    &#34;&#34;&#34;
    return rasters_rio.get_dim_img_path(dim_path, img_name)


@path_xarr_dst
def get_extent(xds: PATH_XARR_DS) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Get the extent of a raster as a `geopandas.Geodataframe`.

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\raster.tif&#34;

    &gt;&gt;&gt; extent1 = get_extent(raster_path)
    &gt;&gt;&gt; # or
    &gt;&gt;&gt; with rasterio.open(raster_path) as dst:
    &gt;&gt;&gt;     extent2 = get_extent(dst)
    &gt;&gt;&gt; extent1 == extent2
    True
    ```

    Args:
        xds (PATH_XARR_DS): Path to the raster or a rasterio dataset or a xarray

    Returns:
        gpd.GeoDataFrame: Extent as a `geopandas.Geodataframe`
    &#34;&#34;&#34;
    return vectors.get_geodf(geometry=[*xds.rio.bounds()], crs=xds.rio.crs)


@path_xarr_dst
def get_footprint(xds: PATH_XARR_DS) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Get real footprint of the product (without nodata, in french == emprise utile)

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\raster.tif&#34;

    &gt;&gt;&gt; footprint1 = get_footprint(raster_path)

    &gt;&gt;&gt; # or
    &gt;&gt;&gt; with rasterio.open(raster_path) as dst:
    &gt;&gt;&gt;     footprint2 = get_footprint(dst)
    &gt;&gt;&gt; footprint1 == footprint2
    ```

    Args:
        xds (PATH_XARR_DS): Path to the raster or a rasterio dataset or a xarray
    Returns:
        gpd.GeoDataFrame: Footprint as a GeoDataFrame
    &#34;&#34;&#34;
    footprint = get_valid_vector(xds)
    return vectors.get_wider_exterior(footprint)


def merge_vrt(
    crs_paths: list, crs_merged_path: Union[str, CloudPath, Path], **kwargs
) -&gt; None:
    &#34;&#34;&#34;
    Merge rasters as a VRT. Uses `gdalbuildvrt`.

    See here: https://gdal.org/programs/gdalbuildvrt.html

    Creates VRT with relative paths !

    .. WARNING::
        They should have the same CRS otherwise the mosaic will be false !

    ```python
    &gt;&gt;&gt; paths_utm32630 = [&#34;path\\to\\raster1.tif&#34;, &#34;path\\to\\raster2.tif&#34;, &#34;path\\to\\raster3.tif&#34;]
    &gt;&gt;&gt; paths_utm32631 = [&#34;path\\to\\raster4.tif&#34;, &#34;path\\to\\raster5.tif&#34;]

    &gt;&gt;&gt; mosaic_32630 = &#34;path\\to\\mosaic_32630.vrt&#34;
    &gt;&gt;&gt; mosaic_32631 = &#34;path\\to\\mosaic_32631.vrt&#34;

    &gt;&gt;&gt; # Create mosaic, one by CRS !
    &gt;&gt;&gt; merge_vrt(paths_utm32630, mosaic_32630)
    &gt;&gt;&gt; merge_vrt(paths_utm32631, mosaic_32631, {&#34;-srcnodata&#34;:255, &#34;-vrtnodata&#34;:0})
    ```

    Args:
        crs_paths (list): Path of the rasters to be merged with the same CRS
        crs_merged_path (Union[str, CloudPath, Path]): Path to the merged raster
        kwargs: Other gdlabuildvrt arguments
    &#34;&#34;&#34;
    return rasters_rio.merge_vrt(crs_paths, crs_merged_path, **kwargs)


def merge_gtiff(
    crs_paths: list, crs_merged_path: Union[str, CloudPath, Path], **kwargs
) -&gt; None:
    &#34;&#34;&#34;
    Merge rasters as a GeoTiff.

    .. WARNING::
        They should have the same CRS otherwise the mosaic will be false !

    ```python
    &gt;&gt;&gt; paths_utm32630 = [&#34;path\\to\\raster1.tif&#34;, &#34;path\\to\\raster2.tif&#34;, &#34;path\\to\\raster3.tif&#34;]
    &gt;&gt;&gt; paths_utm32631 = [&#34;path\\to\\raster4.tif&#34;, &#34;path\\to\\raster5.tif&#34;]

    &gt;&gt;&gt; mosaic_32630 = &#34;path\\to\\mosaic_32630.tif&#34;
    &gt;&gt;&gt; mosaic_32631 = &#34;path\\to\\mosaic_32631.tif&#34;

    # Create mosaic, one by CRS !
    &gt;&gt;&gt; merge_gtiff(paths_utm32630, mosaic_32630)
    &gt;&gt;&gt; merge_gtiff(paths_utm32631, mosaic_32631)
    ```

    Args:
        crs_paths (list): Path of the rasters to be merged with the same CRS
        crs_merged_path (Union[str, CloudPath, Path]): Path to the merged raster
        kwargs: Other rasterio.merge arguments
            More info [here](https://rasterio.readthedocs.io/en/latest/api/rasterio.merge.html#rasterio.merge.merge)
    &#34;&#34;&#34;
    return rasters_rio.merge_gtiff(crs_paths, crs_merged_path, **kwargs)


def unpackbits(array: np.ndarray, nof_bits: int) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Function found here:
    https://stackoverflow.com/questions/18296035/how-to-extract-the-bits-of-larger-numeric-numpy-data-types


    ```python
    &gt;&gt;&gt; bit_array = np.random.randint(5, size=[3,3])
    array([[1, 1, 3],
           [4, 2, 0],
           [4, 3, 2]], dtype=uint8)

    # Unpack 8 bits (8*1, as itemsize of uint8 is 1)
    &gt;&gt;&gt; unpackbits(bit_array, 8)
    array([[[1, 0, 0, 0, 0, 0, 0, 0],
            [1, 0, 0, 0, 0, 0, 0, 0],
            [1, 1, 0, 0, 0, 0, 0, 0]],
           [[0, 0, 1, 0, 0, 0, 0, 0],
            [0, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0]],
           [[0, 0, 1, 0, 0, 0, 0, 0],
            [1, 1, 0, 0, 0, 0, 0, 0],
            [0, 1, 0, 0, 0, 0, 0, 0]]], dtype=uint8)
    ```

    Args:
        array (np.ndarray): Array to unpack
        nof_bits (int): Number of bits to unpack

    Returns:
        np.ndarray: Unpacked array
    &#34;&#34;&#34;
    return rasters_rio.unpackbits(array, nof_bits)


def read_bit_array(
    bit_mask: Union[xr.DataArray, np.ndarray], bit_id: Union[list, int]
) -&gt; Union[np.ndarray, list]:
    &#34;&#34;&#34;
    Read bit arrays as a succession of binary masks (sort of read a slice of the bit mask, slice number bit_id)

    ```python
    &gt;&gt;&gt; bit_array = np.random.randint(5, size=[3,3])
    array([[1, 1, 3],
           [4, 2, 0],
           [4, 3, 2]], dtype=uint8)

    # Get the 2nd bit array
    &gt;&gt;&gt; read_bit_array(bit_array, 2)
    array([[0, 0, 0],
           [1, 0, 0],
           [1, 0, 0]], dtype=uint8)
    ```

    Args:
        bit_mask (np.ndarray): Bit array to read
        bit_id (int): Bit ID of the slice to be read
          Example: read the bit 0 of the mask as a cloud mask (Theia)

    Returns:
        Union[np.ndarray, list]: Binary mask or list of binary masks if a list of bit_id is given
    &#34;&#34;&#34;
    if isinstance(bit_mask, xr.DataArray):
        bit_mask = bit_mask.data

    return rasters_rio.read_bit_array(bit_mask, bit_id)


def read_uint8_array(
    bit_mask: Union[xr.DataArray, np.ndarray], bit_id: Union[list, int]
) -&gt; Union[np.ndarray, list]:
    &#34;&#34;&#34;
    Read 8 bit arrays as a succession of binary masks.

    Forces array to `np.uint8`.

    See `read_bit_array`.

    Args:
        bit_mask (np.ndarray): Bit array to read
        bit_id (int): Bit ID of the slice to be read
          Example: read the bit 0 of the mask as a cloud mask (Theia)

    Returns:
        Union[np.ndarray, list]: Binary mask or list of binary masks if a list of bit_id is given
    &#34;&#34;&#34;
    return read_bit_array(bit_mask.astype(np.uint8), bit_id)


def set_metadata(
    naked_xda: xr.DataArray, mtd_xda: xr.DataArray, new_name=None
) -&gt; xr.DataArray:
    &#34;&#34;&#34;
    Set metadata from a `xr.DataArray` to another (including `rioxarray` metadata such as encoded_nodata and crs).

    Useful when performing operations on xarray that result in metadata loss such as sums.

    ```python
    &gt;&gt;&gt; # xda: some xr.DataArray
    &gt;&gt;&gt; sum = xda + xda  # Sum loses its metadata here
    &lt;xarray.DataArray &#39;xda&#39; (band: 1, y: 322, x: 464)&gt;
    array([[[nan, nan, nan, ..., nan, nan, nan],
            [nan, nan, nan, ..., nan, nan, nan],
            [nan, nan, nan, ..., nan, nan, nan],
            ...,
            [nan, nan, nan, ...,  2., nan, nan],
            [nan, nan, nan, ...,  2., nan, nan],
            [nan, nan, nan, ...,  2., nan, nan]]])
    Coordinates:
      * band         (band) int32 1
      * y            (y) float64 4.798e+06 4.798e+06 ... 4.788e+06 4.788e+06
      * x            (x) float64 5.411e+05 5.411e+05 ... 5.549e+05 5.55e+05

    &gt;&gt;&gt; # We need to set the metadata back (and we can set a new name)
    &gt;&gt;&gt; sum = set_metadata(sum, xda, new_name=&#34;sum&#34;)
    &lt;xarray.DataArray &#39;sum&#39; (band: 1, y: 322, x: 464)&gt;
    array([[[nan, nan, nan, ..., nan, nan, nan],
            [nan, nan, nan, ..., nan, nan, nan],
            [nan, nan, nan, ..., nan, nan, nan],
            ...,
            [nan, nan, nan, ...,  2., nan, nan],
            [nan, nan, nan, ...,  2., nan, nan],
            [nan, nan, nan, ...,  2., nan, nan]]])
    Coordinates:
      * band         (band) int32 1
      * y            (y) float64 4.798e+06 4.798e+06 ... 4.788e+06 4.788e+06
      * x            (x) float64 5.411e+05 5.411e+05 ... 5.549e+05 5.55e+05
        spatial_ref  int32 0
    Attributes: (12/13)
        grid_mapping:              spatial_ref
        BandName:                  Band_1
        RepresentationType:        ATHEMATIC
        STATISTICS_COVARIANCES:    0.2358157950609785
        STATISTICS_MAXIMUM:        2
        STATISTICS_MEAN:           1.3808942647686
        ...                        ...
        STATISTICS_SKIPFACTORX:    1
        STATISTICS_SKIPFACTORY:    1
        STATISTICS_STDDEV:         0.48560665546817
        STATISTICS_VALID_PERCENT:  80.07
        original_dtype:            uint8
    ```

    Args:
        naked_xda (xr.DataArray): DataArray to complete
        mtd_xda (xr.DataArray): DataArray with the correct metadata
        new_name (str): New name for naked DataArray

    Returns:
        xr.DataArray: Complete DataArray
    &#34;&#34;&#34;
    try:
        naked_xda.rio.write_crs(mtd_xda.rio.crs, inplace=True)
    except MissingCRS:
        pass

    if new_name:
        naked_xda = naked_xda.rename(new_name)
    naked_xda.encoding = mtd_xda.encoding

    naked_xda.rio.update_attrs(mtd_xda.attrs, inplace=True)
    naked_xda.rio.set_nodata(mtd_xda.rio.nodata, inplace=True)

    return naked_xda


def set_nodata(xda: xr.DataArray, nodata_val: Union[float, int]) -&gt; xr.DataArray:
    &#34;&#34;&#34;
    Set nodata to a xarray that have no default nodata value.

    In the data array, the no data will be set to `np.nan`.
    The encoded value can be retrieved with `xda.rio.encoded_nodata`.

    ```python
    &gt;&gt;&gt; A = xr.DataArray(dims=(&#34;x&#34;, &#34;y&#34;), data=np.zeros((3,3), dtype=np.uint8))
    &gt;&gt;&gt; A[0, 0] = 1
    &lt;xarray.DataArray (x: 3, y: 3)&gt;
    array([[1, 0, 0],
           [0, 0, 0],
           [0, 0, 0]], dtype=uint8)
    Dimensions without coordinates: x, y

    &gt;&gt;&gt; A_nodata = set_nodata(A, 0)
    &lt;xarray.DataArray (x: 3, y: 3)&gt;
    array([[ 1., nan, nan],
           [nan, nan, nan],
           [nan, nan, nan]])
    Dimensions without coordinates: x, y
    ```

    Args:
        xda (xr.DataArray): DataArray
        nodata_val (Union[float, int]): Nodata value

    Returns:
        xr.DataArray: DataArray with nodata set
    &#34;&#34;&#34;
    xda_nodata = xda.where(xda.data != nodata_val)
    xda_nodata.encoding = xda.encoding
    xda_nodata.rio.update_attrs(xda.attrs, inplace=True)
    xda_nodata.rio.write_nodata(nodata_val, encoded=True, inplace=True)
    return xda_nodata


def where(
    cond, if_true, if_false, master_xda: xr.DataArray = None, new_name: str = &#34;&#34;
) -&gt; xr.DataArray:
    &#34;&#34;&#34;
    Overloads `xr.where` with:

    - setting metadata of `master_xda`
    - preserving the nodata pixels of the `master_xda`

    If `master_xda` is None, use it like `xr.where`.
    Else, it outputs a `xarray.DataArray` with the same dtype than `master_xda`.

    .. WARNING::
        If you don&#39;t give a `master_xda`,
        it is better to pass numpy arrays to `if_false` and `if_true` keywords
        as passing xarrays interfers with the output metadata (you may lose the CRS and so on).
        Just pass `if_true=true_xda.data` inplace of `if_true=true_xda` and the same for `if_false`

    ```python
    &gt;&gt;&gt; A = xr.DataArray(dims=(&#34;x&#34;, &#34;y&#34;), data=[[1, 0, 5], [np.nan, 0, 0]])
    &gt;&gt;&gt; mask_A = rasters.where(A &gt; 3, 0, 1, A, new_name=&#34;mask_A&#34;)
    &lt;xarray.DataArray &#39;mask_A&#39; (x: 2, y: 3)&gt;
    array([[ 1.,  1.,  0.],
           [nan,  1.,  1.]])
    Dimensions without coordinates: x, y
    ```
    Args:
        cond (scalar, array, Variable, DataArray or Dataset): Conditional array
        if_true (scalar, array, Variable, DataArray or Dataset): What to do if `cond` is True
        if_false (scalar, array, Variable, DataArray or Dataset):  What to do if `cond` is False
        master_xda: Master `xr.DataArray` used to set the metadata and the nodata
        new_name (str): New name of the array

    Returns:
        xr.DataArray: Where array with correct mtd and nodata pixels
    &#34;&#34;&#34;
    # Enforce condition
    where_xda = xr.where(cond, if_true, if_false)

    if master_xda is not None:
        # Convert to master dtype
        if where_xda.dtype != master_xda.dtype:
            where_xda = where_xda.astype(master_xda.dtype)

        # Convert to datarray if needed
        if not isinstance(where_xda, xr.DataArray):
            where_xda = master_xda.copy(data=where_xda)

        # Set nodata to nan
        where_xda = where_xda.where(~np.isnan(master_xda))

        # Set mtd
        where_xda = set_metadata(where_xda, master_xda, new_name=new_name)

    return where_xda</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="sertit.rasters.LOGGER"><code class="name">var <span class="ident">LOGGER</span></code></dt>
<dd>
<div class="desc"><p>Types:</p>
<ul>
<li>Path</li>
<li>rasterio Dataset</li>
<li><code>xarray.DataArray</code> and <code>xarray.Dataset</code></li>
</ul></div>
</dd>
<dt id="sertit.rasters.XDS_TYPE"><code class="name">var <span class="ident">XDS_TYPE</span></code></dt>
<dd>
<div class="desc"><p>Xarray types: xr.Dataset and xr.DataArray</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sertit.rasters.path_xarr_dst"><code class="name flex">
<p>def <span class="ident">path_xarr_dst</span>(</p><p>function)</p>
</code></dt>
<dd>
<div class="desc"><p>Path, <code>xarray</code> or dataset decorator. Allows a function to ingest:</p>
<ul>
<li>a path</li>
<li>a <code>xarray</code></li>
<li>a <code>rasterio</code> dataset</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; # Create mock function
&gt;&gt;&gt; @path_or_dst
&gt;&gt;&gt; def fct(dst):
&gt;&gt;&gt;     read(dst)
&gt;&gt;&gt;
&gt;&gt;&gt; # Test the two ways
&gt;&gt;&gt; read1 = fct(&quot;path\to\raster.tif&quot;)
&gt;&gt;&gt; with rasterio.open(&quot;path\to\raster.tif&quot;) as dst:
&gt;&gt;&gt;     read2 = fct(dst)
&gt;&gt;&gt;
&gt;&gt;&gt; # Test
&gt;&gt;&gt; read1 == read2
True
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>function</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Function to decorate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Callable</code></dt>
<dd>decorated function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def path_xarr_dst(function: Callable) -&gt; Callable:
    &#34;&#34;&#34;
    Path, `xarray` or dataset decorator. Allows a function to ingest:

    - a path
    - a `xarray`
    - a `rasterio` dataset

    ```python
    &gt;&gt;&gt; # Create mock function
    &gt;&gt;&gt; @path_or_dst
    &gt;&gt;&gt; def fct(dst):
    &gt;&gt;&gt;     read(dst)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Test the two ways
    &gt;&gt;&gt; read1 = fct(&#34;path\\to\\raster.tif&#34;)
    &gt;&gt;&gt; with rasterio.open(&#34;path\\to\\raster.tif&#34;) as dst:
    &gt;&gt;&gt;     read2 = fct(dst)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Test
    &gt;&gt;&gt; read1 == read2
    True
    ```
    Args:
        function (Callable): Function to decorate

    Returns:
        Callable: decorated function
    &#34;&#34;&#34;

    @wraps(function)
    def path_or_xarr_or_dst_wrapper(path_or_ds: PATH_XARR_DS, *args, **kwargs) -&gt; Any:
        &#34;&#34;&#34;
        Path or dataset wrapper
        Args:
            path_or_ds (PATH_XARR_DS): Raster path or its dataset
            *args: args
            **kwargs: kwargs

        Returns:
            Any: regular output
        &#34;&#34;&#34;
        if isinstance(path_or_ds, xr.DataArray):
            out = function(path_or_ds, *args, **kwargs)
        elif isinstance(path_or_ds, xr.Dataset):
            # Try on the whole dataset
            try:
                out = function(path_or_ds, *args, **kwargs)
            except Exception:
                # Try on every dataarray
                try:
                    xds_dict = {}
                    convert_to_xdataset = False
                    for var in path_or_ds.data_vars:
                        xds_dict[var] = function(path_or_ds[var], *args, **kwargs)
                        if isinstance(xds_dict[var], xr.DataArray):
                            convert_to_xdataset = True

                    # Convert in dataset if we have dataarrays, else keep the dict
                    if convert_to_xdataset:
                        xds = xr.Dataset(xds_dict)
                    else:
                        xds = xds_dict
                    return xds
                except Exception as ex:
                    raise TypeError(&#34;Function not available for xarray.Dataset&#34;) from ex
        else:
            # Get name
            if isinstance(path_or_ds, (str, Path, CloudPath)):
                name = str(path_or_ds)
                path_or_ds = str(path_or_ds)
            else:
                name = path_or_ds.name

            with rioxarray.open_rasterio(
                path_or_ds, masked=True, default_name=name, chunks=True
            ) as xds:
                out = function(xds, *args, **kwargs)
        return out

    return path_or_xarr_or_dst_wrapper</code></pre>
</details>
</dd>
<dt id="sertit.rasters.to_np"><code class="name flex">
<p>def <span class="ident">to_np</span>(</p><p>xds, <br>dtype=None)</p>
</code></dt>
<dd>
<div class="desc"><p>Convert the <code>xarray</code> to a <code>np.ndarray</code> with the correct nodata encoded.</p>
<p>This is particularly useful when reading with <code>masked=True</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; raster_path = &quot;path\to\mask.tif&quot;  # Classified raster in np.uint8 with nodata = 255
&gt;&gt;&gt; # We read with masked=True so the data is converted to float
&gt;&gt;&gt; xds = read(raster_path)
&lt;xarray.DataArray 'path/to/mask.tif' (band: 1, y: 322, x: 464)&gt;
[149408 values with dtype=float64]
Coordinates:
  * band         (band) int32 1
  * y            (y) float64 4.798e+06 4.798e+06 ... 4.788e+06 4.788e+06
  * x            (x) float64 5.411e+05 5.411e+05 ... 5.549e+05 5.55e+05
    spatial_ref  int32 0
&gt;&gt;&gt; to_np(xds)  # Getting back np.uint8 and encoded nodata
array([[[255, 255, 255, ..., 255, 255, 255],
    [255, 255, 255, ..., 255, 255, 255],
    [255, 255, 255, ..., 255, 255, 255],
    ...,
    [255, 255, 255, ...,   1, 255, 255],
    [255, 255, 255, ...,   1, 255, 255],
    [255, 255, 255, ...,   1, 255, 255]]], dtype=uint8)

True
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xds</code></strong> :&ensp;<code>xarray.DataArray</code></dt>
<dd><code>xarray.DataArray</code> to convert</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>Any</code></dt>
<dd>Dtype to convert to. If None, using the origin dtype if existing or its current dtype.</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_np(xds: xarray.DataArray, dtype: Any = None) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Convert the `xarray` to a `np.ndarray` with the correct nodata encoded.

    This is particularly useful when reading with `masked=True`.

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\mask.tif&#34;  # Classified raster in np.uint8 with nodata = 255
    &gt;&gt;&gt; # We read with masked=True so the data is converted to float
    &gt;&gt;&gt; xds = read(raster_path)
    &lt;xarray.DataArray &#39;path/to/mask.tif&#39; (band: 1, y: 322, x: 464)&gt;
    [149408 values with dtype=float64]
    Coordinates:
      * band         (band) int32 1
      * y            (y) float64 4.798e+06 4.798e+06 ... 4.788e+06 4.788e+06
      * x            (x) float64 5.411e+05 5.411e+05 ... 5.549e+05 5.55e+05
        spatial_ref  int32 0
    &gt;&gt;&gt; to_np(xds)  # Getting back np.uint8 and encoded nodata
    array([[[255, 255, 255, ..., 255, 255, 255],
        [255, 255, 255, ..., 255, 255, 255],
        [255, 255, 255, ..., 255, 255, 255],
        ...,
        [255, 255, 255, ...,   1, 255, 255],
        [255, 255, 255, ...,   1, 255, 255],
        [255, 255, 255, ...,   1, 255, 255]]], dtype=uint8)

    True
    ```
    Args:
        xds (xarray.DataArray): `xarray.DataArray` to convert
        dtype (Any): Dtype to convert to. If None, using the origin dtype if existing or its current dtype.

    Returns:

    &#34;&#34;&#34;
    # Manage dtype
    if not dtype:
        dtype = xds.encoding.get(&#34;dtype&#34;, xds.dtype)

    # Manage nodata
    if xds.rio.encoded_nodata is not None:
        xds_fill = xds.fillna(xds.rio.encoded_nodata)
    else:
        xds_fill = xds

    # Cast to wanted dtype
    arr = xds_fill.data.astype(dtype)

    return arr</code></pre>
</details>
</dd>
<dt id="sertit.rasters.get_nodata_mask"><code class="name flex">
<p>def <span class="ident">get_nodata_mask</span>(</p><p>xds)</p>
</code></dt>
<dd>
<div class="desc"><p>Get nodata mask from a xarray.</p>
<pre><code class="language-python">&gt;&gt;&gt; diag_arr = xr.DataArray(data=np.diag([1, 2, 3]))
&gt;&gt;&gt; diag_arr.rio.write_nodata(0, inplace=True)
&lt;xarray.DataArray (dim_0: 3, dim_1: 3)&gt;
array([[1, 0, 0],
       [0, 2, 0],
       [0, 0, 3]])
Dimensions without coordinates: dim_0, dim_1

&gt;&gt;&gt; get_nodata_mask(diag_arr)
array([[1, 0, 0],
       [0, 1, 0],
       [0, 0, 1]], dtype=uint8)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xds</code></strong> :&ensp;<code><a title="sertit.rasters.XDS_TYPE" href="#sertit.rasters.XDS_TYPE">XDS_TYPE</a></code></dt>
<dd>Array to evaluate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Pixelwise nodata array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nodata_mask(xds: XDS_TYPE) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Get nodata mask from a xarray.

    ```python
    &gt;&gt;&gt; diag_arr = xr.DataArray(data=np.diag([1, 2, 3]))
    &gt;&gt;&gt; diag_arr.rio.write_nodata(0, inplace=True)
    &lt;xarray.DataArray (dim_0: 3, dim_1: 3)&gt;
    array([[1, 0, 0],
           [0, 2, 0],
           [0, 0, 3]])
    Dimensions without coordinates: dim_0, dim_1

    &gt;&gt;&gt; get_nodata_mask(diag_arr)
    array([[1, 0, 0],
           [0, 1, 0],
           [0, 0, 1]], dtype=uint8)
    ```

    Args:
        xds (XDS_TYPE): Array to evaluate

    Returns:
        np.ndarray: Pixelwise nodata array

    &#34;&#34;&#34;

    nodata = xds.rio.nodata

    try:
        is_nan = np.isnan(nodata)
    except TypeError:
        is_nan = False

    if is_nan:
        nodata_pos = np.isnan(xds.data)
    else:
        nodata_pos = xds.data == nodata

    return np.where(nodata_pos, 0, 1).astype(np.uint8)</code></pre>
</details>
</dd>
<dt id="sertit.rasters.vectorize"><code class="name flex">
<p>def <span class="ident">vectorize</span>(</p><p>xds, <br>values=None, <br>keep_values=True, <br>dissolve=False, <br>default_nodata=0)</p>
</code></dt>
<dd>
<div class="desc"><p>Vectorize a <code>xarray</code> to get the class vectors.</p>
<p>If dissolved is False, it returns a GeoDataFrame with a GeoSeries per cluster of pixel value,
with the value as an attribute. Else it returns a GeoDataFrame with a unique polygon.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<ul>
<li>Your data is casted by force into np.uint8, so be sure that your data is classified.</li>
<li>This could take a while as the computing time directly depends on the number of polygons to vectorize.
Please be careful.</li>
</ul>
</div>
<pre><code class="language-python">&gt;&gt;&gt; raster_path = &quot;path\to\raster.tif&quot;
&gt;&gt;&gt; vec1 = vectorize(raster_path)
&gt;&gt;&gt; # or
&gt;&gt;&gt; with rasterio.open(raster_path) as dst:
&gt;&gt;&gt;     vec2 = vectorize(dst)
&gt;&gt;&gt; vec1 == vec2
True
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xds</code></strong> :&ensp;<code>PATH_XARR_DS</code></dt>
<dd>Path to the raster or a rasterio dataset or a xarray</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>Union[None, int, list]</code></dt>
<dd>Get only the polygons concerning this/these particular values</dd>
<dt><strong><code>keep_values</code></strong> :&ensp;<code>bool</code></dt>
<dd>Keep the passed values. If False, discard them and keep the others.</dd>
<dt><strong><code>dissolve</code></strong> :&ensp;<code>bool</code></dt>
<dd>Dissolve all the polygons into one unique. Only works if values are given.</dd>
<dt><strong><code>default_nodata</code></strong> :&ensp;<code>int</code></dt>
<dd>Default values for nodata in case of non existing in file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gpd.GeoDataFrame</code></dt>
<dd>Classes Vector</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@path_xarr_dst
def vectorize(
    xds: PATH_XARR_DS,
    values: Union[None, int, list] = None,
    keep_values: bool = True,
    dissolve: bool = False,
    default_nodata: int = 0,
) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Vectorize a `xarray` to get the class vectors.

    If dissolved is False, it returns a GeoDataFrame with a GeoSeries per cluster of pixel value,
    with the value as an attribute. Else it returns a GeoDataFrame with a unique polygon.

    .. WARNING::
        - Your data is casted by force into np.uint8, so be sure that your data is classified.
        - This could take a while as the computing time directly depends on the number of polygons to vectorize.
            Please be careful.

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\raster.tif&#34;
    &gt;&gt;&gt; vec1 = vectorize(raster_path)
    &gt;&gt;&gt; # or
    &gt;&gt;&gt; with rasterio.open(raster_path) as dst:
    &gt;&gt;&gt;     vec2 = vectorize(dst)
    &gt;&gt;&gt; vec1 == vec2
    True
    ```

    Args:
        xds (PATH_XARR_DS): Path to the raster or a rasterio dataset or a xarray
        values (Union[None, int, list]): Get only the polygons concerning this/these particular values
        keep_values (bool): Keep the passed values. If False, discard them and keep the others.
        dissolve (bool): Dissolve all the polygons into one unique. Only works if values are given.
        default_nodata (int): Default values for nodata in case of non existing in file
    Returns:
        gpd.GeoDataFrame: Classes Vector
    &#34;&#34;&#34;
    return _vectorize(
        xds,
        values=values,
        keep_values=keep_values,
        dissolve=dissolve,
        get_nodata=False,
        default_nodata=default_nodata,
    )</code></pre>
</details>
</dd>
<dt id="sertit.rasters.get_valid_vector"><code class="name flex">
<p>def <span class="ident">get_valid_vector</span>(</p><p>xds, <br>default_nodata=0)</p>
</code></dt>
<dd>
<div class="desc"><p>Get the valid data of a raster as a vector.</p>
<p>Pay attention that every nodata pixel will appear too.
If you want only the footprint of the raster, please use <code><a title="sertit.rasters.get_footprint" href="#sertit.rasters.get_footprint">get_footprint()</a></code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; raster_path = &quot;path\to\raster.tif&quot;
&gt;&gt;&gt; nodata1 = get_nodata_vec(raster_path)
&gt;&gt;&gt; # or
&gt;&gt;&gt; with rasterio.open(raster_path) as dst:
&gt;&gt;&gt;     nodata2 = get_nodata_vec(dst)
&gt;&gt;&gt; nodata1 == nodata2
True
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xds</code></strong> :&ensp;<code>PATH_XARR_DS</code></dt>
<dd>Path to the raster or a rasterio dataset or a xarray</dd>
<dt><strong><code>default_nodata</code></strong> :&ensp;<code>int</code></dt>
<dd>Default values for nodata in case of non existing in file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gpd.GeoDataFrame</code></dt>
<dd>Nodata Vector</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@path_xarr_dst
def get_valid_vector(xds: PATH_XARR_DS, default_nodata: int = 0) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Get the valid data of a raster as a vector.

    Pay attention that every nodata pixel will appear too.
    If you want only the footprint of the raster, please use `get_footprint`.

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\raster.tif&#34;
    &gt;&gt;&gt; nodata1 = get_nodata_vec(raster_path)
    &gt;&gt;&gt; # or
    &gt;&gt;&gt; with rasterio.open(raster_path) as dst:
    &gt;&gt;&gt;     nodata2 = get_nodata_vec(dst)
    &gt;&gt;&gt; nodata1 == nodata2
    True
    ```

    Args:
        xds (PATH_XARR_DS): Path to the raster or a rasterio dataset or a xarray
        default_nodata (int): Default values for nodata in case of non existing in file
    Returns:
        gpd.GeoDataFrame: Nodata Vector

    &#34;&#34;&#34;
    nodata = _vectorize(
        xds, values=None, get_nodata=True, default_nodata=default_nodata
    )
    return nodata[
        nodata.raster_val != 0
    ]  # 0 is the values of not nodata put there by rasterio</code></pre>
</details>
</dd>
<dt id="sertit.rasters.get_nodata_vector"><code class="name flex">
<p>def <span class="ident">get_nodata_vector</span>(</p><p>dst, <br>default_nodata=0)</p>
</code></dt>
<dd>
<div class="desc"><p>Get the nodata vector of a raster as a vector.</p>
<p>Pay attention that every nodata pixel will appear too.
If you want only the footprint of the raster, please use <code><a title="sertit.rasters.get_footprint" href="#sertit.rasters.get_footprint">get_footprint()</a></code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; raster_path = &quot;path\to\raster.tif&quot;  # Classified raster, with no data set to 255
&gt;&gt;&gt; nodata1 = get_nodata_vec(raster_path)
&gt;&gt;&gt; # or
&gt;&gt;&gt; with rasterio.open(raster_path) as dst:
&gt;&gt;&gt;     nodata2 = get_nodata_vec(dst)
&gt;&gt;&gt; nodata1 == nodata2
True
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dst</code></strong> :&ensp;<code>PATH_ARR_DS</code></dt>
<dd>Path to the raster, its dataset, its <code>xarray</code> or a tuple containing its array and metadata</dd>
<dt><strong><code>default_nodata</code></strong> :&ensp;<code>int</code></dt>
<dd>Default values for nodata in case of non existing in file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gpd.GeoDataFrame</code></dt>
<dd>Nodata Vector</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@path_xarr_dst
def get_nodata_vector(dst: PATH_ARR_DS, default_nodata: int = 0) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Get the nodata vector of a raster as a vector.

    Pay attention that every nodata pixel will appear too.
    If you want only the footprint of the raster, please use `get_footprint`.

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\raster.tif&#34;  # Classified raster, with no data set to 255
    &gt;&gt;&gt; nodata1 = get_nodata_vec(raster_path)
    &gt;&gt;&gt; # or
    &gt;&gt;&gt; with rasterio.open(raster_path) as dst:
    &gt;&gt;&gt;     nodata2 = get_nodata_vec(dst)
    &gt;&gt;&gt; nodata1 == nodata2
    True
    ```

    Args:
        dst (PATH_ARR_DS): Path to the raster, its dataset, its `xarray` or a tuple containing its array and metadata
        default_nodata (int): Default values for nodata in case of non existing in file
    Returns:
        gpd.GeoDataFrame: Nodata Vector

    &#34;&#34;&#34;
    nodata = _vectorize(
        dst, values=None, get_nodata=True, default_nodata=default_nodata
    )
    return nodata[nodata.raster_val == 0]</code></pre>
</details>
</dd>
<dt id="sertit.rasters.mask"><code class="name flex">
<p>def <span class="ident">mask</span>(</p><p>xds, <br>shapes, <br>nodata=None, <br>**kwargs)</p>
</code></dt>
<dd>
<div class="desc"><p>Masking a dataset:
setting nodata outside of the given shapes, but without cropping the raster to the shapes extent.</p>
<p>The original nodata is kept and completed with the nodata provided by the shapes.</p>
<p>Overload of rasterio mask function in order to create a <code>xarray</code>.</p>
<p>The <code><a title="sertit.rasters.mask" href="#sertit.rasters.mask">mask()</a></code> function docs can be seen <a href="https://rasterio.readthedocs.io/en/latest/api/rasterio.mask.html">here</a>.
It basically masks a raster with a vector mask, with the possibility to crop the raster to the vector's extent.</p>
<pre><code class="language-python">&gt;&gt;&gt; raster_path = &quot;path\to\raster.tif&quot;
&gt;&gt;&gt; shape_path = &quot;path\to\shapes.geojson&quot;  # Any vector that geopandas can read
&gt;&gt;&gt; shapes = gpd.read_file(shape_path)
&gt;&gt;&gt; mask1 = mask(raster_path, shapes)
&gt;&gt;&gt; # or
&gt;&gt;&gt; with rasterio.open(raster_path) as dst:
&gt;&gt;&gt;     mask2 = mask(dst, shapes)
&gt;&gt;&gt; mask1 == mask2
True
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xds</code></strong> :&ensp;<code>PATH_XARR_DS</code></dt>
<dd>Path to the raster or a rasterio dataset or a xarray</dd>
<dt><strong><code>shapes</code></strong> :&ensp;<code>Union[gpd.GeoDataFrame, Polygon, list]</code></dt>
<dd>Shapes with the same CRS as the dataset
(except if a <code>GeoDataFrame</code> is passed, in which case it will automatically be converted)</dd>
<dt><strong><code>nodata</code></strong> :&ensp;<code>int</code></dt>
<dd>Nodata value. If not set, uses the ds.nodata. If doesnt exist, set to 0.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Other rasterio.mask options</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sertit.rasters.XDS_TYPE" href="#sertit.rasters.XDS_TYPE">XDS_TYPE</a></code></dt>
<dd>Masked array as a xarray</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@path_xarr_dst
def mask(
    xds: PATH_XARR_DS,
    shapes: Union[gpd.GeoDataFrame, Polygon, list],
    nodata: Optional[int] = None,
    **kwargs,
) -&gt; XDS_TYPE:
    &#34;&#34;&#34;
    Masking a dataset:
    setting nodata outside of the given shapes, but without cropping the raster to the shapes extent.

    The original nodata is kept and completed with the nodata provided by the shapes.

    Overload of rasterio mask function in order to create a `xarray`.

    The `mask` function docs can be seen [here](https://rasterio.readthedocs.io/en/latest/api/rasterio.mask.html).
    It basically masks a raster with a vector mask, with the possibility to crop the raster to the vector&#39;s extent.

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\raster.tif&#34;
    &gt;&gt;&gt; shape_path = &#34;path\\to\\shapes.geojson&#34;  # Any vector that geopandas can read
    &gt;&gt;&gt; shapes = gpd.read_file(shape_path)
    &gt;&gt;&gt; mask1 = mask(raster_path, shapes)
    &gt;&gt;&gt; # or
    &gt;&gt;&gt; with rasterio.open(raster_path) as dst:
    &gt;&gt;&gt;     mask2 = mask(dst, shapes)
    &gt;&gt;&gt; mask1 == mask2
    True
    ```

    Args:
        xds (PATH_XARR_DS): Path to the raster or a rasterio dataset or a xarray
        shapes (Union[gpd.GeoDataFrame, Polygon, list]): Shapes with the same CRS as the dataset
            (except if a `GeoDataFrame` is passed, in which case it will automatically be converted)
        nodata (int): Nodata value. If not set, uses the ds.nodata. If doesnt exist, set to 0.
        **kwargs: Other rasterio.mask options

    Returns:
         XDS_TYPE: Masked array as a xarray
    &#34;&#34;&#34;
    # Use classic option
    arr, meta = rasters_rio.mask(xds, shapes=shapes, nodata=nodata, **kwargs)

    masked_xds = xds.copy(data=arr)

    if nodata:
        masked_xds = set_nodata(masked_xds, nodata)

    # Convert back to xarray
    return masked_xds</code></pre>
</details>
</dd>
<dt id="sertit.rasters.paint"><code class="name flex">
<p>def <span class="ident">paint</span>(</p><p>xds, <br>shapes, <br>value, <br>invert=False, <br>**kwargs)</p>
</code></dt>
<dd>
<div class="desc"><p>Painting a dataset: setting values inside the given shapes. To set outside the shape, set invert=True.
Pay attention that this behavior is the opposite of the <code>rasterio.mask</code> function.</p>
<p>The original nodata is kept.
This means if your shapes intersects the original nodata,
the value of the pixel will be set to nodata rather than to the wanted value.</p>
<p>Overload of rasterio mask function in order to create a <code>xarray</code>.
The <code><a title="sertit.rasters.mask" href="#sertit.rasters.mask">mask()</a></code> function docs can be seen <a href="https://rasterio.readthedocs.io/en/latest/api/rasterio.mask.html">here</a>.</p>
<pre><code class="language-python">&gt;&gt;&gt; raster_path = &quot;path\to\raster.tif&quot;
&gt;&gt;&gt; shape_path = &quot;path\to\shapes.geojson&quot;  # Any vector that geopandas can read
&gt;&gt;&gt; shapes = gpd.read_file(shape_path)
&gt;&gt;&gt; paint1 = paint(raster_path, shapes, value=100)
&gt;&gt;&gt; # or
&gt;&gt;&gt; with rasterio.open(raster_path) as dst:
&gt;&gt;&gt;     paint2 = paint(dst, shapes, value=100)
&gt;&gt;&gt; paint1 == paint2
True
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xds</code></strong> :&ensp;<code>PATH_XARR_DS</code></dt>
<dd>Path to the raster or a rasterio dataset or a xarray</dd>
<dt><strong><code>shapes</code></strong> :&ensp;<code>Union[gpd.GeoDataFrame, Polygon, list]</code></dt>
<dd>Shapes with the same CRS as the dataset
(except if a <code>GeoDataFrame</code> is passed, in which case it will automatically be converted)</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>Value to set on the shapes.</dd>
<dt><strong><code>invert</code></strong> :&ensp;<code>bool</code></dt>
<dd>If invert is True, set value outside the shapes.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Other rasterio.mask options</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sertit.rasters.XDS_TYPE" href="#sertit.rasters.XDS_TYPE">XDS_TYPE</a></code></dt>
<dd>Painted array as a xarray</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@path_xarr_dst
def paint(
    xds: PATH_XARR_DS,
    shapes: Union[gpd.GeoDataFrame, Polygon, list],
    value: int,
    invert: bool = False,
    **kwargs,
) -&gt; XDS_TYPE:
    &#34;&#34;&#34;
    Painting a dataset: setting values inside the given shapes. To set outside the shape, set invert=True.
    Pay attention that this behavior is the opposite of the `rasterio.mask` function.

    The original nodata is kept.
    This means if your shapes intersects the original nodata,
    the value of the pixel will be set to nodata rather than to the wanted value.

    Overload of rasterio mask function in order to create a `xarray`.
    The `mask` function docs can be seen [here](https://rasterio.readthedocs.io/en/latest/api/rasterio.mask.html).

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\raster.tif&#34;
    &gt;&gt;&gt; shape_path = &#34;path\\to\\shapes.geojson&#34;  # Any vector that geopandas can read
    &gt;&gt;&gt; shapes = gpd.read_file(shape_path)
    &gt;&gt;&gt; paint1 = paint(raster_path, shapes, value=100)
    &gt;&gt;&gt; # or
    &gt;&gt;&gt; with rasterio.open(raster_path) as dst:
    &gt;&gt;&gt;     paint2 = paint(dst, shapes, value=100)
    &gt;&gt;&gt; paint1 == paint2
    True
    ```

    Args:
        xds (PATH_XARR_DS): Path to the raster or a rasterio dataset or a xarray
        shapes (Union[gpd.GeoDataFrame, Polygon, list]): Shapes with the same CRS as the dataset
            (except if a `GeoDataFrame` is passed, in which case it will automatically be converted)
        value (int): Value to set on the shapes.
        invert (bool): If invert is True, set value outside the shapes.
        **kwargs: Other rasterio.mask options

    Returns:
         XDS_TYPE: Painted array as a xarray
    &#34;&#34;&#34;
    # Fill na values in order to not interfere with the mask function
    if xds.rio.encoded_nodata is not None:
        xds_fill = xds.fillna(xds.rio.encoded_nodata)
    elif xds.rio.nodata is not None:
        xds_fill = xds.fillna(xds.rio.nodata)
    else:
        xds_fill = xds

    # Use classic option
    arr, meta = rasters_rio.mask(
        xds_fill, shapes=shapes, nodata=value, invert=not invert, **kwargs
    )

    # Create and fill na values created by the mask to the wanted value
    painted_xds = xds.copy(data=arr)
    painted_xds = painted_xds.fillna(value)

    # Set back nodata to keep the original nodata
    if xds.rio.encoded_nodata is not None:
        painted_xds = set_nodata(painted_xds, xds.rio.encoded_nodata)

    # Convert back to xarray
    return painted_xds</code></pre>
</details>
</dd>
<dt id="sertit.rasters.crop"><code class="name flex">
<p>def <span class="ident">crop</span>(</p><p>xds, <br>shapes, <br>nodata=None, <br>**kwargs)</p>
</code></dt>
<dd>
<div class="desc"><p>Cropping a dataset:
setting nodata outside of the given shapes AND cropping the raster to the shapes extent.</p>
<p>Overload of <a href="https://corteva.github.io/rioxarray/stable/rioxarray.html#rioxarray.raster_array.RasterArray.clip"><code>rioxarray</code>
clip</a>
function in order to create a masked_array.</p>
<pre><code class="language-python">&gt;&gt;&gt; raster_path = &quot;path\to\raster.tif&quot;
&gt;&gt;&gt; shape_path = &quot;path\to\shapes.geojson&quot;  # Any vector that geopandas can read
&gt;&gt;&gt; shapes = gpd.read_file(shape_path)
&gt;&gt;&gt; xds2 = crop(raster_path, shapes)
&gt;&gt;&gt; # or
&gt;&gt;&gt; with rasterio.open(raster_path) as dst:
&gt;&gt;&gt;     xds2 = crop(dst, shapes)
&gt;&gt;&gt; xds1 == xds2
True
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xds</code></strong> :&ensp;<code>PATH_XARR_DS</code></dt>
<dd>Path to the raster or a rasterio dataset or a xarray</dd>
<dt><strong><code>shapes</code></strong> :&ensp;<code>Union[gpd.GeoDataFrame, Polygon, list]</code></dt>
<dd>Shapes with the same CRS as the dataset
(except if a <code>GeoDataFrame</code> is passed, in which case it will automatically be converted)</dd>
<dt><strong><code>nodata</code></strong> :&ensp;<code>int</code></dt>
<dd>Nodata value. If not set, uses the ds.nodata. If doesnt exist, set to 0.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Other rioxarray.clip options</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sertit.rasters.XDS_TYPE" href="#sertit.rasters.XDS_TYPE">XDS_TYPE</a></code></dt>
<dd>Cropped array as a xarray</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@path_xarr_dst
def crop(
    xds: PATH_XARR_DS,
    shapes: Union[gpd.GeoDataFrame, Polygon, list],
    nodata: Optional[int] = None,
    **kwargs,
) -&gt; (np.ma.masked_array, dict):
    &#34;&#34;&#34;
    Cropping a dataset:
    setting nodata outside of the given shapes AND cropping the raster to the shapes extent.

    Overload of [`rioxarray`
    clip](https://corteva.github.io/rioxarray/stable/rioxarray.html#rioxarray.raster_array.RasterArray.clip)
    function in order to create a masked_array.

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\raster.tif&#34;
    &gt;&gt;&gt; shape_path = &#34;path\\to\\shapes.geojson&#34;  # Any vector that geopandas can read
    &gt;&gt;&gt; shapes = gpd.read_file(shape_path)
    &gt;&gt;&gt; xds2 = crop(raster_path, shapes)
    &gt;&gt;&gt; # or
    &gt;&gt;&gt; with rasterio.open(raster_path) as dst:
    &gt;&gt;&gt;     xds2 = crop(dst, shapes)
    &gt;&gt;&gt; xds1 == xds2
    True
    ```

    Args:
        xds (PATH_XARR_DS): Path to the raster or a rasterio dataset or a xarray
        shapes (Union[gpd.GeoDataFrame, Polygon, list]): Shapes with the same CRS as the dataset
            (except if a `GeoDataFrame` is passed, in which case it will automatically be converted)
        nodata (int): Nodata value. If not set, uses the ds.nodata. If doesnt exist, set to 0.
        **kwargs: Other rioxarray.clip options

    Returns:
         XDS_TYPE: Cropped array as a xarray
    &#34;&#34;&#34;
    if nodata:
        xds_new = xds.rio.write_nodata(nodata)
    else:
        xds_new = xds

    if isinstance(shapes, (gpd.GeoDataFrame, gpd.GeoSeries)):
        shapes = shapes.to_crs(xds.rio.crs).geometry

    if &#34;from_disk&#34; not in kwargs:
        kwargs[&#34;from_disk&#34;] = True  # WAY FASTER

    return xds_new.rio.clip(shapes, **kwargs)</code></pre>
</details>
</dd>
<dt id="sertit.rasters.read"><code class="name flex">
<p>def <span class="ident">read</span>(</p><p>dst, <br>resolution=None, <br>size=None, <br>resampling=Resampling.nearest, <br>masked=True, <br>indexes=None, <br>chunks=None, <br>**kwargs)</p>
</code></dt>
<dd>
<div class="desc"><p>Read a raster dataset from a :</p>
<ul>
<li><code>xarray</code> (compatibility issues)</li>
<li><code>rasterio.Dataset</code></li>
<li><code>rasterio</code> opened data (array, metadata)</li>
<li>a path.</li>
</ul>
<p>The resolution can be provided (in dataset unit) as:</p>
<ul>
<li>a tuple or a list of (X, Y) resolutions</li>
<li>a float, in which case X resolution = Y resolution</li>
<li>None, in which case the dataset resolution will be used</li>
</ul>
<p>Uses <a href="https://corteva.github.io/rioxarray/stable/rioxarray.html#rioxarray-open-rasterio">rioxarray.open_rasterio</a>.
For Dask usage, you can look at the
<a href="https://corteva.github.io/rioxarray/stable/examples/dask_read_write.html">rioxarray tutorial</a>.</p>
<pre><code class="language-python">&gt;&gt;&gt; raster_path = &quot;path\to\raster.tif&quot;
&gt;&gt;&gt; xds1 = read(raster_path)
&gt;&gt;&gt; # or
&gt;&gt;&gt; with rasterio.open(raster_path) as dst:
&gt;&gt;&gt;    xds2 = read(dst)
&gt;&gt;&gt; xds1 == xds2
True
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dst</code></strong> :&ensp;<code>PATH_ARR_DS</code></dt>
<dd>Path to the raster or a rasterio dataset or a xarray</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>Union[tuple, list, float]</code></dt>
<dd>Resolution of the wanted band, in dataset resolution unit (X, Y)</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>Union[tuple, list]</code></dt>
<dd>Size of the array (width, height). Not used if resolution is provided.</dd>
<dt><strong><code>resampling</code></strong> :&ensp;<code>Resampling</code></dt>
<dd>Resampling method</dd>
<dt><strong><code>masked</code></strong> :&ensp;<code>bool</code></dt>
<dd>Get a masked array</dd>
<dt><strong><code>indexes</code></strong> :&ensp;<code>Union[int, list]</code></dt>
<dd>Indexes to load. Load the whole array if None.</dd>
<dt><strong><code>chunks</code></strong> :&ensp;<code>int, tuple</code> or <code>dict</code></dt>
<dd>Chunk sizes along each dimension, e.g., 5, (5, 5) or {'x': 5, 'y': 5}.
If chunks is provided, it used to load the new DataArray into a dask array.
Chunks can also be set to True or "auto" to choose sensible chunk sizes
according to dask.config.get("array.chunk-size").</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Optional keyword arguments to pass into rioxarray.open_rasterio().</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="sertit.rasters.XDS_TYPE" href="#sertit.rasters.XDS_TYPE">XDS_TYPE</a>]</code></dt>
<dd>Masked xarray corresponding to the raster data and its meta data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@path_arr_dst
def read(
    dst: PATH_ARR_DS,
    resolution: Union[tuple, list, float] = None,
    size: Union[tuple, list] = None,
    resampling: Resampling = Resampling.nearest,
    masked: bool = True,
    indexes: Union[int, list] = None,
    chunks: Union[int, tuple, dict] = None,
    **kwargs,
) -&gt; XDS_TYPE:
    &#34;&#34;&#34;
    Read a raster dataset from a :

    - `xarray` (compatibility issues)
    - `rasterio.Dataset`
    - `rasterio` opened data (array, metadata)
    - a path.

    The resolution can be provided (in dataset unit) as:

    - a tuple or a list of (X, Y) resolutions
    - a float, in which case X resolution = Y resolution
    - None, in which case the dataset resolution will be used

    Uses [rioxarray.open_rasterio](https://corteva.github.io/rioxarray/stable/rioxarray.html#rioxarray-open-rasterio).
    For Dask usage, you can look at the
    [rioxarray tutorial](https://corteva.github.io/rioxarray/stable/examples/dask_read_write.html).

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\raster.tif&#34;
    &gt;&gt;&gt; xds1 = read(raster_path)
    &gt;&gt;&gt; # or
    &gt;&gt;&gt; with rasterio.open(raster_path) as dst:
    &gt;&gt;&gt;    xds2 = read(dst)
    &gt;&gt;&gt; xds1 == xds2
    True
    ```

    Args:
        dst (PATH_ARR_DS): Path to the raster or a rasterio dataset or a xarray
        resolution (Union[tuple, list, float]): Resolution of the wanted band, in dataset resolution unit (X, Y)
        size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        resampling (Resampling): Resampling method
        masked (bool): Get a masked array
        indexes (Union[int, list]): Indexes to load. Load the whole array if None.
        chunks (int, tuple or dict): Chunk sizes along each dimension, e.g., 5, (5, 5) or {&#39;x&#39;: 5, &#39;y&#39;: 5}.
            If chunks is provided, it used to load the new DataArray into a dask array.
            Chunks can also be set to True or &#34;auto&#34; to choose sensible chunk sizes
            according to dask.config.get(&#34;array.chunk-size&#34;).
        **kwargs: Optional keyword arguments to pass into rioxarray.open_rasterio().
    Returns:
        Union[XDS_TYPE]: Masked xarray corresponding to the raster data and its meta data

    &#34;&#34;&#34;
    # Get new height and width
    new_height, new_width = rasters_rio.get_new_shape(dst, resolution, size)

    # Read data (and load it to discard lock)
    with xarray.set_options(keep_attrs=True):
        with rioxarray.open_rasterio(
            dst, default_name=files.get_filename(dst.name), chunks=chunks, **kwargs
        ) as xda:
            orig_dtype = xda.dtype
            if indexes:
                if not isinstance(indexes, list):
                    indexes = [indexes]

                # Open only wanted bands
                xda = xda[np.isin(xda.band, indexes)]

                try:
                    # Set new long name: Bands nb are idx + 1
                    xda.long_name = tuple(
                        name for i, name in enumerate(xda.long_name) if i + 1 in indexes
                    )
                except AttributeError:
                    pass

            # Manage resampling
            if new_height != dst.height or new_width != dst.width:
                factor_h = dst.height / new_height
                factor_w = dst.width / new_width
                if factor_h.is_integer() and factor_w.is_integer():
                    xda = xda.coarsen(x=int(factor_w), y=int(factor_h)).mean()
                else:
                    xda = xda.rio.reproject(
                        xda.rio.crs,
                        shape=(new_height, new_width),
                        resampling=resampling,
                    )

            if masked:
                # Set nodata not in opening due to some performance issues
                xda = set_nodata(xda, dst.meta[&#34;nodata&#34;])

            # Set original dtype
            xda.encoding[&#34;dtype&#34;] = orig_dtype

    return xda</code></pre>
</details>
</dd>
<dt id="sertit.rasters.write"><code class="name flex">
<p>def <span class="ident">write</span>(</p><p>xds, <br>path, <br>**kwargs)</p>
</code></dt>
<dd>
<div class="desc"><p>Write raster to disk.
(encapsulation of <code>rasterio</code>'s function, because for now <code>rioxarray</code> to_raster doesn't work as expected)</p>
<p>Metadata will be created with the <code>xarray</code> metadata (ie. width, height, count, type&hellip;)
The driver is <code>GTiff</code> by default, and no nodata value is provided.
The file will be compressed if the raster is a mask (saved as uint8).</p>
<p>If not overwritten, sets the nodata according to <code>dtype</code>:</p>
<ul>
<li>uint8: 255</li>
<li>int8: -128</li>
<li>uint16, uint32, int32, int64, uint64: 65535</li>
<li>int16, float32, float64, float128, float: -9999</li>
</ul>
<p>Compress with <code>LZW</code> option by default. To disable it, add the <code>compress=None</code> parameter.</p>
<pre><code class="language-python">&gt;&gt;&gt; raster_path = &quot;path\to\raster.tif&quot;
&gt;&gt;&gt; raster_out = &quot;path\to\out.tif&quot;

&gt;&gt;&gt; # Read raster
&gt;&gt;&gt; xds = read(raster_path)

&gt;&gt;&gt; # Rewrite it
&gt;&gt;&gt; write(xds, raster_out)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xds</code></strong> :&ensp;<code><a title="sertit.rasters.XDS_TYPE" href="#sertit.rasters.XDS_TYPE">XDS_TYPE</a></code></dt>
<dd>Path to the raster or a rasterio dataset or a xarray</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[str, CloudPath, Path]</code></dt>
<dd>Path where to save it (directories should be existing)</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Overloading metadata, ie <code>nodata=255</code> or <code>dtype=np.uint8</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@path_xarr_dst
def write(xds: XDS_TYPE, path: Union[str, CloudPath, Path], **kwargs) -&gt; None:
    &#34;&#34;&#34;
    Write raster to disk.
    (encapsulation of `rasterio`&#39;s function, because for now `rioxarray` to_raster doesn&#39;t work as expected)

    Metadata will be created with the `xarray` metadata (ie. width, height, count, type...)
    The driver is `GTiff` by default, and no nodata value is provided.
    The file will be compressed if the raster is a mask (saved as uint8).

    If not overwritten, sets the nodata according to `dtype`:

    - uint8: 255
    - int8: -128
    - uint16, uint32, int32, int64, uint64: 65535
    - int16, float32, float64, float128, float: -9999

    Compress with `LZW` option by default. To disable it, add the `compress=None` parameter.

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\raster.tif&#34;
    &gt;&gt;&gt; raster_out = &#34;path\\to\\out.tif&#34;

    &gt;&gt;&gt; # Read raster
    &gt;&gt;&gt; xds = read(raster_path)

    &gt;&gt;&gt; # Rewrite it
    &gt;&gt;&gt; write(xds, raster_out)
    ```

    Args:
        xds (XDS_TYPE): Path to the raster or a rasterio dataset or a xarray
        path (Union[str, CloudPath, Path]): Path where to save it (directories should be existing)
        **kwargs: Overloading metadata, ie `nodata=255` or `dtype=np.uint8`
    &#34;&#34;&#34;
    if &#34;nodata&#34; in kwargs:
        xds.encoding[&#34;_FillValue&#34;] = kwargs.pop(&#34;nodata&#34;)
    else:
        # Manage default nodata in function of dtype (default, for float = -9999)
        if &#34;dtype&#34; in kwargs:
            dtype = kwargs[&#34;dtype&#34;]
        else:
            dtype = xds.dtype

        # Convert to numpy dtype
        if isinstance(dtype, str):
            dtype = getattr(np, dtype)

        if dtype == np.uint8:
            xds.encoding[&#34;_FillValue&#34;] = 255
        elif dtype == np.int8:
            xds.encoding[&#34;_FillValue&#34;] = -128
        elif dtype in [np.uint16, np.uint32, np.int32, np.int64, np.uint64, int]:
            xds.encoding[&#34;_FillValue&#34;] = 65535
        elif dtype in [np.int16, np.float32, np.float64, float]:
            xds.encoding[&#34;_FillValue&#34;] = -9999
        else:
            raise ValueError(
                f&#34;Invalid dtype: {dtype}, should be convertible to numpy dtypes&#34;
            )

    # Default compression to LZW
    if &#34;compress&#34; not in kwargs:
        kwargs[&#34;compress&#34;] = &#34;lzw&#34;

    # WORKAROUND: Pop _FillValue attribute
    if &#34;_FillValue&#34; in xds.attrs:
        xds.attrs.pop(&#34;_FillValue&#34;)

    # Bigtiff if needed
    if xds.data.size * xds.data.itemsize / 1024 / 1024 / 1024 &gt; 4:
        bigtiff = &#34;YES&#34;
    else:
        bigtiff = &#34;IF_NEEDED&#34;

    # Manage tiles
    if &#34;tiled&#34; not in kwargs:
        kwargs[&#34;tiled&#34;] = True

    # Force GTiff
    kwargs[&#34;driver&#34;] = &#34;GTiff&#34;

    # Write on disk
    xds.rio.to_raster(str(path), BIGTIFF=bigtiff, NUM_THREADS=MAX_CORES, **kwargs)</code></pre>
</details>
</dd>
<dt id="sertit.rasters.collocate"><code class="name flex">
<p>def <span class="ident">collocate</span>(</p><p>master_xds, <br>slave_xds, <br>resampling=Resampling.nearest)</p>
</code></dt>
<dd>
<div class="desc"><p>Collocate two georeferenced arrays:
forces the <em>slave</em> raster to be exactly georeferenced onto the <em>master</em> raster by reprojection.</p>
<p>Use it like <code>OTB SuperImpose</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; master_path = &quot;path\to\master.tif&quot;
&gt;&gt;&gt; slave_path = &quot;path\to\slave.tif&quot;
&gt;&gt;&gt; col_path = &quot;path\to\collocated.tif&quot;

&gt;&gt;&gt; # Collocate the slave to the master
&gt;&gt;&gt; col_xds = collocate(read(master_path), read(slave_path), Resampling.bilinear)

&gt;&gt;&gt; # Write it
&gt;&gt;&gt; write(col_xds, col_path)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>master_xds</code></strong> :&ensp;<code><a title="sertit.rasters.XDS_TYPE" href="#sertit.rasters.XDS_TYPE">XDS_TYPE</a></code></dt>
<dd>Master xarray</dd>
<dt><strong><code>slave_xds</code></strong> :&ensp;<code><a title="sertit.rasters.XDS_TYPE" href="#sertit.rasters.XDS_TYPE">XDS_TYPE</a></code></dt>
<dd>Slave xarray</dd>
<dt><strong><code>resampling</code></strong> :&ensp;<code>Resampling</code></dt>
<dd>Resampling method</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sertit.rasters.XDS_TYPE" href="#sertit.rasters.XDS_TYPE">XDS_TYPE</a></code></dt>
<dd>Collocated xarray</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collocate(
    master_xds: XDS_TYPE,
    slave_xds: XDS_TYPE,
    resampling: Resampling = Resampling.nearest,
) -&gt; XDS_TYPE:
    &#34;&#34;&#34;
    Collocate two georeferenced arrays:
    forces the *slave* raster to be exactly georeferenced onto the *master* raster by reprojection.

    Use it like `OTB SuperImpose`.

    ```python
    &gt;&gt;&gt; master_path = &#34;path\\to\\master.tif&#34;
    &gt;&gt;&gt; slave_path = &#34;path\\to\\slave.tif&#34;
    &gt;&gt;&gt; col_path = &#34;path\\to\\collocated.tif&#34;

    &gt;&gt;&gt; # Collocate the slave to the master
    &gt;&gt;&gt; col_xds = collocate(read(master_path), read(slave_path), Resampling.bilinear)

    &gt;&gt;&gt; # Write it
    &gt;&gt;&gt; write(col_xds, col_path)
    ```

    Args:
        master_xds (XDS_TYPE): Master xarray
        slave_xds (XDS_TYPE): Slave xarray
        resampling (Resampling): Resampling method

    Returns:
        XDS_TYPE: Collocated xarray

    &#34;&#34;&#34;
    collocated_xds = slave_xds.rio.reproject_match(master_xds, resampling=resampling)
    collocated_xds = collocated_xds.assign_coords(
        {
            &#34;x&#34;: master_xds.x,
            &#34;y&#34;: master_xds.y,
        }
    )  # Bug for now, tiny difference in coords
    return collocated_xds</code></pre>
</details>
</dd>
<dt id="sertit.rasters.sieve"><code class="name flex">
<p>def <span class="ident">sieve</span>(</p><p>xds, <br>sieve_thresh, <br>connectivity=4, <br>dtype=numpy.uint8)</p>
</code></dt>
<dd>
<div class="desc"><p>Sieving, overloads rasterio function with raster shaped like (1, h, w).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Your data is casted by force into <code>np.uint8</code>, so be sure that your data is classified.</p>
</div>
<pre><code class="language-python">&gt;&gt;&gt; raster_path = &quot;path\to\raster.tif&quot;  # classified raster

&gt;&gt;&gt; # Rewrite it
&gt;&gt;&gt; sieved_xds = sieve(raster_path, sieve_thresh=20)

&gt;&gt;&gt; # Write it
&gt;&gt;&gt; raster_out = &quot;path\to\raster_sieved.tif&quot;
&gt;&gt;&gt; write(sieved_xds, raster_out)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xds</code></strong> :&ensp;<code>PATH_XARR_DS</code></dt>
<dd>Path to the raster or a rasterio dataset or a xarray</dd>
<dt><strong><code>sieve_thresh</code></strong> :&ensp;<code>int</code></dt>
<dd>Sieving threshold in pixels</dd>
<dt><strong><code>connectivity</code></strong> :&ensp;<code>int</code></dt>
<dd>Connectivity, either 4 or 8</dd>
<dt><strong><code>dtype</code></strong></dt>
<dd>Dtype of the xarray
(if nodata is set, the xds.dtype is float whereas the values are meant to be ie in np.uint8)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(XDS_TYPE): Sieved xarray</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@path_xarr_dst
def sieve(
    xds: PATH_XARR_DS, sieve_thresh: int, connectivity: int = 4, dtype=np.uint8
) -&gt; XDS_TYPE:
    &#34;&#34;&#34;
    Sieving, overloads rasterio function with raster shaped like (1, h, w).

    .. WARNING::
        Your data is casted by force into `np.uint8`, so be sure that your data is classified.

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\raster.tif&#34;  # classified raster

    &gt;&gt;&gt; # Rewrite it
    &gt;&gt;&gt; sieved_xds = sieve(raster_path, sieve_thresh=20)

    &gt;&gt;&gt; # Write it
    &gt;&gt;&gt; raster_out = &#34;path\\to\\raster_sieved.tif&#34;
    &gt;&gt;&gt; write(sieved_xds, raster_out)
    ```

    Args:
        xds (PATH_XARR_DS): Path to the raster or a rasterio dataset or a xarray
        sieve_thresh (int): Sieving threshold in pixels
        connectivity (int): Connectivity, either 4 or 8
        dtype: Dtype of the xarray
            (if nodata is set, the xds.dtype is float whereas the values are meant to be ie in np.uint8)

    Returns:
        (XDS_TYPE): Sieved xarray
    &#34;&#34;&#34;
    assert connectivity in [4, 8]

    # Use this trick to make the sieve work
    data = np.squeeze(to_np(xds, dtype))

    # Sieve
    try:
        sieved_arr = features.sieve(data, size=sieve_thresh, connectivity=connectivity)
    except TypeError:
        # Manage dask arrays that fails with rasterio sieve
        sieved_arr = features.sieve(
            data.compute(), size=sieve_thresh, connectivity=connectivity
        )

    # Create back the xarray
    sieved_arr = np.expand_dims(sieved_arr.astype(xds.dtype), axis=0)
    sieved_xds = xds.copy(data=sieved_arr)

    # Set back nodata
    if xds.rio.encoded_nodata is not None:
        sieved_xds = set_nodata(sieved_xds, xds.rio.encoded_nodata)

    return sieved_xds</code></pre>
</details>
</dd>
<dt id="sertit.rasters.get_dim_img_path"><code class="name flex">
<p>def <span class="ident">get_dim_img_path</span>(</p><p>dim_path, <br>img_name='*')</p>
</code></dt>
<dd>
<div class="desc"><p>Get the image path from a <em>BEAM-DIMAP</em> data.</p>
<p>A <em>BEAM-DIMAP</em> file cannot be opened by rasterio, although its .img file can.</p>
<pre><code class="language-python">&gt;&gt;&gt; dim_path = &quot;path\to\dimap.dim&quot;  # BEAM-DIMAP image
&gt;&gt;&gt; img_path = get_dim_img_path(dim_path)

&gt;&gt;&gt; # Read raster
&gt;&gt;&gt; raster, meta = read(img_path)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dim_path</code></strong> :&ensp;<code>Union[str, CloudPath, Path]</code></dt>
<dd>DIM path (.dim or .data)</dd>
<dt><strong><code>img_name</code></strong> :&ensp;<code>str</code></dt>
<dd>.img file name (or regex), in case there are multiple .img files (ie. for S3 data)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[CloudPath, Path]</code></dt>
<dd>.img file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dim_img_path(
    dim_path: Union[str, CloudPath, Path], img_name: str = &#34;*&#34;
) -&gt; Union[CloudPath, Path]:
    &#34;&#34;&#34;
    Get the image path from a *BEAM-DIMAP* data.

    A *BEAM-DIMAP* file cannot be opened by rasterio, although its .img file can.

    ```python
    &gt;&gt;&gt; dim_path = &#34;path\\to\\dimap.dim&#34;  # BEAM-DIMAP image
    &gt;&gt;&gt; img_path = get_dim_img_path(dim_path)

    &gt;&gt;&gt; # Read raster
    &gt;&gt;&gt; raster, meta = read(img_path)
    ```

    Args:
        dim_path (Union[str, CloudPath, Path]): DIM path (.dim or .data)
        img_name (str): .img file name (or regex), in case there are multiple .img files (ie. for S3 data)

    Returns:
        Union[CloudPath, Path]: .img file
    &#34;&#34;&#34;
    return rasters_rio.get_dim_img_path(dim_path, img_name)</code></pre>
</details>
</dd>
<dt id="sertit.rasters.get_extent"><code class="name flex">
<p>def <span class="ident">get_extent</span>(</p><p>xds)</p>
</code></dt>
<dd>
<div class="desc"><p>Get the extent of a raster as a <code>geopandas.Geodataframe</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; raster_path = &quot;path\to\raster.tif&quot;

&gt;&gt;&gt; extent1 = get_extent(raster_path)
&gt;&gt;&gt; # or
&gt;&gt;&gt; with rasterio.open(raster_path) as dst:
&gt;&gt;&gt;     extent2 = get_extent(dst)
&gt;&gt;&gt; extent1 == extent2
True
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xds</code></strong> :&ensp;<code>PATH_XARR_DS</code></dt>
<dd>Path to the raster or a rasterio dataset or a xarray</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gpd.GeoDataFrame</code></dt>
<dd>Extent as a <code>geopandas.Geodataframe</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@path_xarr_dst
def get_extent(xds: PATH_XARR_DS) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Get the extent of a raster as a `geopandas.Geodataframe`.

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\raster.tif&#34;

    &gt;&gt;&gt; extent1 = get_extent(raster_path)
    &gt;&gt;&gt; # or
    &gt;&gt;&gt; with rasterio.open(raster_path) as dst:
    &gt;&gt;&gt;     extent2 = get_extent(dst)
    &gt;&gt;&gt; extent1 == extent2
    True
    ```

    Args:
        xds (PATH_XARR_DS): Path to the raster or a rasterio dataset or a xarray

    Returns:
        gpd.GeoDataFrame: Extent as a `geopandas.Geodataframe`
    &#34;&#34;&#34;
    return vectors.get_geodf(geometry=[*xds.rio.bounds()], crs=xds.rio.crs)</code></pre>
</details>
</dd>
<dt id="sertit.rasters.get_footprint"><code class="name flex">
<p>def <span class="ident">get_footprint</span>(</p><p>xds)</p>
</code></dt>
<dd>
<div class="desc"><p>Get real footprint of the product (without nodata, in french == emprise utile)</p>
<pre><code class="language-python">&gt;&gt;&gt; raster_path = &quot;path\to\raster.tif&quot;

&gt;&gt;&gt; footprint1 = get_footprint(raster_path)

&gt;&gt;&gt; # or
&gt;&gt;&gt; with rasterio.open(raster_path) as dst:
&gt;&gt;&gt;     footprint2 = get_footprint(dst)
&gt;&gt;&gt; footprint1 == footprint2
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xds</code></strong> :&ensp;<code>PATH_XARR_DS</code></dt>
<dd>Path to the raster or a rasterio dataset or a xarray</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gpd.GeoDataFrame</code></dt>
<dd>Footprint as a GeoDataFrame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@path_xarr_dst
def get_footprint(xds: PATH_XARR_DS) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Get real footprint of the product (without nodata, in french == emprise utile)

    ```python
    &gt;&gt;&gt; raster_path = &#34;path\\to\\raster.tif&#34;

    &gt;&gt;&gt; footprint1 = get_footprint(raster_path)

    &gt;&gt;&gt; # or
    &gt;&gt;&gt; with rasterio.open(raster_path) as dst:
    &gt;&gt;&gt;     footprint2 = get_footprint(dst)
    &gt;&gt;&gt; footprint1 == footprint2
    ```

    Args:
        xds (PATH_XARR_DS): Path to the raster or a rasterio dataset or a xarray
    Returns:
        gpd.GeoDataFrame: Footprint as a GeoDataFrame
    &#34;&#34;&#34;
    footprint = get_valid_vector(xds)
    return vectors.get_wider_exterior(footprint)</code></pre>
</details>
</dd>
<dt id="sertit.rasters.merge_vrt"><code class="name flex">
<p>def <span class="ident">merge_vrt</span>(</p><p>crs_paths, <br>crs_merged_path, <br>**kwargs)</p>
</code></dt>
<dd>
<div class="desc"><p>Merge rasters as a VRT. Uses <code>gdalbuildvrt</code>.</p>
<p>See here: <a href="https://gdal.org/programs/gdalbuildvrt.html">https://gdal.org/programs/gdalbuildvrt.html</a></p>
<p>Creates VRT with relative paths !</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>They should have the same CRS otherwise the mosaic will be false !</p>
</div>
<pre><code class="language-python">&gt;&gt;&gt; paths_utm32630 = [&quot;path\to\raster1.tif&quot;, &quot;path\to\raster2.tif&quot;, &quot;path\to\raster3.tif&quot;]
&gt;&gt;&gt; paths_utm32631 = [&quot;path\to\raster4.tif&quot;, &quot;path\to\raster5.tif&quot;]

&gt;&gt;&gt; mosaic_32630 = &quot;path\to\mosaic_32630.vrt&quot;
&gt;&gt;&gt; mosaic_32631 = &quot;path\to\mosaic_32631.vrt&quot;

&gt;&gt;&gt; # Create mosaic, one by CRS !
&gt;&gt;&gt; merge_vrt(paths_utm32630, mosaic_32630)
&gt;&gt;&gt; merge_vrt(paths_utm32631, mosaic_32631, {&quot;-srcnodata&quot;:255, &quot;-vrtnodata&quot;:0})
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>crs_paths</code></strong> :&ensp;<code>list</code></dt>
<dd>Path of the rasters to be merged with the same CRS</dd>
<dt><strong><code>crs_merged_path</code></strong> :&ensp;<code>Union[str, CloudPath, Path]</code></dt>
<dd>Path to the merged raster</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Other gdlabuildvrt arguments</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_vrt(
    crs_paths: list, crs_merged_path: Union[str, CloudPath, Path], **kwargs
) -&gt; None:
    &#34;&#34;&#34;
    Merge rasters as a VRT. Uses `gdalbuildvrt`.

    See here: https://gdal.org/programs/gdalbuildvrt.html

    Creates VRT with relative paths !

    .. WARNING::
        They should have the same CRS otherwise the mosaic will be false !

    ```python
    &gt;&gt;&gt; paths_utm32630 = [&#34;path\\to\\raster1.tif&#34;, &#34;path\\to\\raster2.tif&#34;, &#34;path\\to\\raster3.tif&#34;]
    &gt;&gt;&gt; paths_utm32631 = [&#34;path\\to\\raster4.tif&#34;, &#34;path\\to\\raster5.tif&#34;]

    &gt;&gt;&gt; mosaic_32630 = &#34;path\\to\\mosaic_32630.vrt&#34;
    &gt;&gt;&gt; mosaic_32631 = &#34;path\\to\\mosaic_32631.vrt&#34;

    &gt;&gt;&gt; # Create mosaic, one by CRS !
    &gt;&gt;&gt; merge_vrt(paths_utm32630, mosaic_32630)
    &gt;&gt;&gt; merge_vrt(paths_utm32631, mosaic_32631, {&#34;-srcnodata&#34;:255, &#34;-vrtnodata&#34;:0})
    ```

    Args:
        crs_paths (list): Path of the rasters to be merged with the same CRS
        crs_merged_path (Union[str, CloudPath, Path]): Path to the merged raster
        kwargs: Other gdlabuildvrt arguments
    &#34;&#34;&#34;
    return rasters_rio.merge_vrt(crs_paths, crs_merged_path, **kwargs)</code></pre>
</details>
</dd>
<dt id="sertit.rasters.merge_gtiff"><code class="name flex">
<p>def <span class="ident">merge_gtiff</span>(</p><p>crs_paths, <br>crs_merged_path, <br>**kwargs)</p>
</code></dt>
<dd>
<div class="desc"><p>Merge rasters as a GeoTiff.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>They should have the same CRS otherwise the mosaic will be false !</p>
</div>
<pre><code class="language-python">&gt;&gt;&gt; paths_utm32630 = [&quot;path\to\raster1.tif&quot;, &quot;path\to\raster2.tif&quot;, &quot;path\to\raster3.tif&quot;]
&gt;&gt;&gt; paths_utm32631 = [&quot;path\to\raster4.tif&quot;, &quot;path\to\raster5.tif&quot;]

&gt;&gt;&gt; mosaic_32630 = &quot;path\to\mosaic_32630.tif&quot;
&gt;&gt;&gt; mosaic_32631 = &quot;path\to\mosaic_32631.tif&quot;

# Create mosaic, one by CRS !
&gt;&gt;&gt; merge_gtiff(paths_utm32630, mosaic_32630)
&gt;&gt;&gt; merge_gtiff(paths_utm32631, mosaic_32631)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>crs_paths</code></strong> :&ensp;<code>list</code></dt>
<dd>Path of the rasters to be merged with the same CRS</dd>
<dt><strong><code>crs_merged_path</code></strong> :&ensp;<code>Union[str, CloudPath, Path]</code></dt>
<dd>Path to the merged raster</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Other rasterio.merge arguments
More info <a href="https://rasterio.readthedocs.io/en/latest/api/rasterio.merge.html#rasterio.merge.merge">here</a></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_gtiff(
    crs_paths: list, crs_merged_path: Union[str, CloudPath, Path], **kwargs
) -&gt; None:
    &#34;&#34;&#34;
    Merge rasters as a GeoTiff.

    .. WARNING::
        They should have the same CRS otherwise the mosaic will be false !

    ```python
    &gt;&gt;&gt; paths_utm32630 = [&#34;path\\to\\raster1.tif&#34;, &#34;path\\to\\raster2.tif&#34;, &#34;path\\to\\raster3.tif&#34;]
    &gt;&gt;&gt; paths_utm32631 = [&#34;path\\to\\raster4.tif&#34;, &#34;path\\to\\raster5.tif&#34;]

    &gt;&gt;&gt; mosaic_32630 = &#34;path\\to\\mosaic_32630.tif&#34;
    &gt;&gt;&gt; mosaic_32631 = &#34;path\\to\\mosaic_32631.tif&#34;

    # Create mosaic, one by CRS !
    &gt;&gt;&gt; merge_gtiff(paths_utm32630, mosaic_32630)
    &gt;&gt;&gt; merge_gtiff(paths_utm32631, mosaic_32631)
    ```

    Args:
        crs_paths (list): Path of the rasters to be merged with the same CRS
        crs_merged_path (Union[str, CloudPath, Path]): Path to the merged raster
        kwargs: Other rasterio.merge arguments
            More info [here](https://rasterio.readthedocs.io/en/latest/api/rasterio.merge.html#rasterio.merge.merge)
    &#34;&#34;&#34;
    return rasters_rio.merge_gtiff(crs_paths, crs_merged_path, **kwargs)</code></pre>
</details>
</dd>
<dt id="sertit.rasters.unpackbits"><code class="name flex">
<p>def <span class="ident">unpackbits</span>(</p><p>array, <br>nof_bits)</p>
</code></dt>
<dd>
<div class="desc"><p>Function found here:
<a href="https://stackoverflow.com/questions/18296035/how-to-extract-the-bits-of-larger-numeric-numpy-data-types">https://stackoverflow.com/questions/18296035/how-to-extract-the-bits-of-larger-numeric-numpy-data-types</a></p>
<pre><code class="language-python">&gt;&gt;&gt; bit_array = np.random.randint(5, size=[3,3])
array([[1, 1, 3],
       [4, 2, 0],
       [4, 3, 2]], dtype=uint8)

# Unpack 8 bits (8*1, as itemsize of uint8 is 1)
&gt;&gt;&gt; unpackbits(bit_array, 8)
array([[[1, 0, 0, 0, 0, 0, 0, 0],
        [1, 0, 0, 0, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 0, 0, 0]],
       [[0, 0, 1, 0, 0, 0, 0, 0],
        [0, 1, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0]],
       [[0, 0, 1, 0, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 0, 0, 0],
        [0, 1, 0, 0, 0, 0, 0, 0]]], dtype=uint8)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Array to unpack</dd>
<dt><strong><code>nof_bits</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of bits to unpack</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Unpacked array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unpackbits(array: np.ndarray, nof_bits: int) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Function found here:
    https://stackoverflow.com/questions/18296035/how-to-extract-the-bits-of-larger-numeric-numpy-data-types


    ```python
    &gt;&gt;&gt; bit_array = np.random.randint(5, size=[3,3])
    array([[1, 1, 3],
           [4, 2, 0],
           [4, 3, 2]], dtype=uint8)

    # Unpack 8 bits (8*1, as itemsize of uint8 is 1)
    &gt;&gt;&gt; unpackbits(bit_array, 8)
    array([[[1, 0, 0, 0, 0, 0, 0, 0],
            [1, 0, 0, 0, 0, 0, 0, 0],
            [1, 1, 0, 0, 0, 0, 0, 0]],
           [[0, 0, 1, 0, 0, 0, 0, 0],
            [0, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0]],
           [[0, 0, 1, 0, 0, 0, 0, 0],
            [1, 1, 0, 0, 0, 0, 0, 0],
            [0, 1, 0, 0, 0, 0, 0, 0]]], dtype=uint8)
    ```

    Args:
        array (np.ndarray): Array to unpack
        nof_bits (int): Number of bits to unpack

    Returns:
        np.ndarray: Unpacked array
    &#34;&#34;&#34;
    return rasters_rio.unpackbits(array, nof_bits)</code></pre>
</details>
</dd>
<dt id="sertit.rasters.read_bit_array"><code class="name flex">
<p>def <span class="ident">read_bit_array</span>(</p><p>bit_mask, <br>bit_id)</p>
</code></dt>
<dd>
<div class="desc"><p>Read bit arrays as a succession of binary masks (sort of read a slice of the bit mask, slice number bit_id)</p>
<pre><code class="language-python">&gt;&gt;&gt; bit_array = np.random.randint(5, size=[3,3])
array([[1, 1, 3],
       [4, 2, 0],
       [4, 3, 2]], dtype=uint8)

# Get the 2nd bit array
&gt;&gt;&gt; read_bit_array(bit_array, 2)
array([[0, 0, 0],
       [1, 0, 0],
       [1, 0, 0]], dtype=uint8)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bit_mask</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Bit array to read</dd>
<dt><strong><code>bit_id</code></strong> :&ensp;<code>int</code></dt>
<dd>Bit ID of the slice to be read
Example: read the bit 0 of the mask as a cloud mask (Theia)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[np.ndarray, list]</code></dt>
<dd>Binary mask or list of binary masks if a list of bit_id is given</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_bit_array(
    bit_mask: Union[xr.DataArray, np.ndarray], bit_id: Union[list, int]
) -&gt; Union[np.ndarray, list]:
    &#34;&#34;&#34;
    Read bit arrays as a succession of binary masks (sort of read a slice of the bit mask, slice number bit_id)

    ```python
    &gt;&gt;&gt; bit_array = np.random.randint(5, size=[3,3])
    array([[1, 1, 3],
           [4, 2, 0],
           [4, 3, 2]], dtype=uint8)

    # Get the 2nd bit array
    &gt;&gt;&gt; read_bit_array(bit_array, 2)
    array([[0, 0, 0],
           [1, 0, 0],
           [1, 0, 0]], dtype=uint8)
    ```

    Args:
        bit_mask (np.ndarray): Bit array to read
        bit_id (int): Bit ID of the slice to be read
          Example: read the bit 0 of the mask as a cloud mask (Theia)

    Returns:
        Union[np.ndarray, list]: Binary mask or list of binary masks if a list of bit_id is given
    &#34;&#34;&#34;
    if isinstance(bit_mask, xr.DataArray):
        bit_mask = bit_mask.data

    return rasters_rio.read_bit_array(bit_mask, bit_id)</code></pre>
</details>
</dd>
<dt id="sertit.rasters.read_uint8_array"><code class="name flex">
<p>def <span class="ident">read_uint8_array</span>(</p><p>bit_mask, <br>bit_id)</p>
</code></dt>
<dd>
<div class="desc"><p>Read 8 bit arrays as a succession of binary masks.</p>
<p>Forces array to <code>np.uint8</code>.</p>
<p>See <code><a title="sertit.rasters.read_bit_array" href="#sertit.rasters.read_bit_array">read_bit_array()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bit_mask</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Bit array to read</dd>
<dt><strong><code>bit_id</code></strong> :&ensp;<code>int</code></dt>
<dd>Bit ID of the slice to be read
Example: read the bit 0 of the mask as a cloud mask (Theia)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[np.ndarray, list]</code></dt>
<dd>Binary mask or list of binary masks if a list of bit_id is given</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_uint8_array(
    bit_mask: Union[xr.DataArray, np.ndarray], bit_id: Union[list, int]
) -&gt; Union[np.ndarray, list]:
    &#34;&#34;&#34;
    Read 8 bit arrays as a succession of binary masks.

    Forces array to `np.uint8`.

    See `read_bit_array`.

    Args:
        bit_mask (np.ndarray): Bit array to read
        bit_id (int): Bit ID of the slice to be read
          Example: read the bit 0 of the mask as a cloud mask (Theia)

    Returns:
        Union[np.ndarray, list]: Binary mask or list of binary masks if a list of bit_id is given
    &#34;&#34;&#34;
    return read_bit_array(bit_mask.astype(np.uint8), bit_id)</code></pre>
</details>
</dd>
<dt id="sertit.rasters.set_metadata"><code class="name flex">
<p>def <span class="ident">set_metadata</span>(</p><p>naked_xda, <br>mtd_xda, <br>new_name=None)</p>
</code></dt>
<dd>
<div class="desc"><p>Set metadata from a <code>xr.DataArray</code> to another (including <code>rioxarray</code> metadata such as encoded_nodata and crs).</p>
<p>Useful when performing operations on xarray that result in metadata loss such as sums.</p>
<pre><code class="language-python">&gt;&gt;&gt; # xda: some xr.DataArray
&gt;&gt;&gt; sum = xda + xda  # Sum loses its metadata here
&lt;xarray.DataArray 'xda' (band: 1, y: 322, x: 464)&gt;
array([[[nan, nan, nan, ..., nan, nan, nan],
        [nan, nan, nan, ..., nan, nan, nan],
        [nan, nan, nan, ..., nan, nan, nan],
        ...,
        [nan, nan, nan, ...,  2., nan, nan],
        [nan, nan, nan, ...,  2., nan, nan],
        [nan, nan, nan, ...,  2., nan, nan]]])
Coordinates:
  * band         (band) int32 1
  * y            (y) float64 4.798e+06 4.798e+06 ... 4.788e+06 4.788e+06
  * x            (x) float64 5.411e+05 5.411e+05 ... 5.549e+05 5.55e+05

&gt;&gt;&gt; # We need to set the metadata back (and we can set a new name)
&gt;&gt;&gt; sum = set_metadata(sum, xda, new_name=&quot;sum&quot;)
&lt;xarray.DataArray 'sum' (band: 1, y: 322, x: 464)&gt;
array([[[nan, nan, nan, ..., nan, nan, nan],
        [nan, nan, nan, ..., nan, nan, nan],
        [nan, nan, nan, ..., nan, nan, nan],
        ...,
        [nan, nan, nan, ...,  2., nan, nan],
        [nan, nan, nan, ...,  2., nan, nan],
        [nan, nan, nan, ...,  2., nan, nan]]])
Coordinates:
  * band         (band) int32 1
  * y            (y) float64 4.798e+06 4.798e+06 ... 4.788e+06 4.788e+06
  * x            (x) float64 5.411e+05 5.411e+05 ... 5.549e+05 5.55e+05
    spatial_ref  int32 0
Attributes: (12/13)
    grid_mapping:              spatial_ref
    BandName:                  Band_1
    RepresentationType:        ATHEMATIC
    STATISTICS_COVARIANCES:    0.2358157950609785
    STATISTICS_MAXIMUM:        2
    STATISTICS_MEAN:           1.3808942647686
    ...                        ...
    STATISTICS_SKIPFACTORX:    1
    STATISTICS_SKIPFACTORY:    1
    STATISTICS_STDDEV:         0.48560665546817
    STATISTICS_VALID_PERCENT:  80.07
    original_dtype:            uint8
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>naked_xda</code></strong> :&ensp;<code>xr.DataArray</code></dt>
<dd>DataArray to complete</dd>
<dt><strong><code>mtd_xda</code></strong> :&ensp;<code>xr.DataArray</code></dt>
<dd>DataArray with the correct metadata</dd>
<dt><strong><code>new_name</code></strong> :&ensp;<code>str</code></dt>
<dd>New name for naked DataArray</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xr.DataArray</code></dt>
<dd>Complete DataArray</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_metadata(
    naked_xda: xr.DataArray, mtd_xda: xr.DataArray, new_name=None
) -&gt; xr.DataArray:
    &#34;&#34;&#34;
    Set metadata from a `xr.DataArray` to another (including `rioxarray` metadata such as encoded_nodata and crs).

    Useful when performing operations on xarray that result in metadata loss such as sums.

    ```python
    &gt;&gt;&gt; # xda: some xr.DataArray
    &gt;&gt;&gt; sum = xda + xda  # Sum loses its metadata here
    &lt;xarray.DataArray &#39;xda&#39; (band: 1, y: 322, x: 464)&gt;
    array([[[nan, nan, nan, ..., nan, nan, nan],
            [nan, nan, nan, ..., nan, nan, nan],
            [nan, nan, nan, ..., nan, nan, nan],
            ...,
            [nan, nan, nan, ...,  2., nan, nan],
            [nan, nan, nan, ...,  2., nan, nan],
            [nan, nan, nan, ...,  2., nan, nan]]])
    Coordinates:
      * band         (band) int32 1
      * y            (y) float64 4.798e+06 4.798e+06 ... 4.788e+06 4.788e+06
      * x            (x) float64 5.411e+05 5.411e+05 ... 5.549e+05 5.55e+05

    &gt;&gt;&gt; # We need to set the metadata back (and we can set a new name)
    &gt;&gt;&gt; sum = set_metadata(sum, xda, new_name=&#34;sum&#34;)
    &lt;xarray.DataArray &#39;sum&#39; (band: 1, y: 322, x: 464)&gt;
    array([[[nan, nan, nan, ..., nan, nan, nan],
            [nan, nan, nan, ..., nan, nan, nan],
            [nan, nan, nan, ..., nan, nan, nan],
            ...,
            [nan, nan, nan, ...,  2., nan, nan],
            [nan, nan, nan, ...,  2., nan, nan],
            [nan, nan, nan, ...,  2., nan, nan]]])
    Coordinates:
      * band         (band) int32 1
      * y            (y) float64 4.798e+06 4.798e+06 ... 4.788e+06 4.788e+06
      * x            (x) float64 5.411e+05 5.411e+05 ... 5.549e+05 5.55e+05
        spatial_ref  int32 0
    Attributes: (12/13)
        grid_mapping:              spatial_ref
        BandName:                  Band_1
        RepresentationType:        ATHEMATIC
        STATISTICS_COVARIANCES:    0.2358157950609785
        STATISTICS_MAXIMUM:        2
        STATISTICS_MEAN:           1.3808942647686
        ...                        ...
        STATISTICS_SKIPFACTORX:    1
        STATISTICS_SKIPFACTORY:    1
        STATISTICS_STDDEV:         0.48560665546817
        STATISTICS_VALID_PERCENT:  80.07
        original_dtype:            uint8
    ```

    Args:
        naked_xda (xr.DataArray): DataArray to complete
        mtd_xda (xr.DataArray): DataArray with the correct metadata
        new_name (str): New name for naked DataArray

    Returns:
        xr.DataArray: Complete DataArray
    &#34;&#34;&#34;
    try:
        naked_xda.rio.write_crs(mtd_xda.rio.crs, inplace=True)
    except MissingCRS:
        pass

    if new_name:
        naked_xda = naked_xda.rename(new_name)
    naked_xda.encoding = mtd_xda.encoding

    naked_xda.rio.update_attrs(mtd_xda.attrs, inplace=True)
    naked_xda.rio.set_nodata(mtd_xda.rio.nodata, inplace=True)

    return naked_xda</code></pre>
</details>
</dd>
<dt id="sertit.rasters.set_nodata"><code class="name flex">
<p>def <span class="ident">set_nodata</span>(</p><p>xda, <br>nodata_val)</p>
</code></dt>
<dd>
<div class="desc"><p>Set nodata to a xarray that have no default nodata value.</p>
<p>In the data array, the no data will be set to <code>np.nan</code>.
The encoded value can be retrieved with <code>xda.rio.encoded_nodata</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; A = xr.DataArray(dims=(&quot;x&quot;, &quot;y&quot;), data=np.zeros((3,3), dtype=np.uint8))
&gt;&gt;&gt; A[0, 0] = 1
&lt;xarray.DataArray (x: 3, y: 3)&gt;
array([[1, 0, 0],
       [0, 0, 0],
       [0, 0, 0]], dtype=uint8)
Dimensions without coordinates: x, y

&gt;&gt;&gt; A_nodata = set_nodata(A, 0)
&lt;xarray.DataArray (x: 3, y: 3)&gt;
array([[ 1., nan, nan],
       [nan, nan, nan],
       [nan, nan, nan]])
Dimensions without coordinates: x, y
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xda</code></strong> :&ensp;<code>xr.DataArray</code></dt>
<dd>DataArray</dd>
<dt><strong><code>nodata_val</code></strong> :&ensp;<code>Union[float, int]</code></dt>
<dd>Nodata value</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xr.DataArray</code></dt>
<dd>DataArray with nodata set</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_nodata(xda: xr.DataArray, nodata_val: Union[float, int]) -&gt; xr.DataArray:
    &#34;&#34;&#34;
    Set nodata to a xarray that have no default nodata value.

    In the data array, the no data will be set to `np.nan`.
    The encoded value can be retrieved with `xda.rio.encoded_nodata`.

    ```python
    &gt;&gt;&gt; A = xr.DataArray(dims=(&#34;x&#34;, &#34;y&#34;), data=np.zeros((3,3), dtype=np.uint8))
    &gt;&gt;&gt; A[0, 0] = 1
    &lt;xarray.DataArray (x: 3, y: 3)&gt;
    array([[1, 0, 0],
           [0, 0, 0],
           [0, 0, 0]], dtype=uint8)
    Dimensions without coordinates: x, y

    &gt;&gt;&gt; A_nodata = set_nodata(A, 0)
    &lt;xarray.DataArray (x: 3, y: 3)&gt;
    array([[ 1., nan, nan],
           [nan, nan, nan],
           [nan, nan, nan]])
    Dimensions without coordinates: x, y
    ```

    Args:
        xda (xr.DataArray): DataArray
        nodata_val (Union[float, int]): Nodata value

    Returns:
        xr.DataArray: DataArray with nodata set
    &#34;&#34;&#34;
    xda_nodata = xda.where(xda.data != nodata_val)
    xda_nodata.encoding = xda.encoding
    xda_nodata.rio.update_attrs(xda.attrs, inplace=True)
    xda_nodata.rio.write_nodata(nodata_val, encoded=True, inplace=True)
    return xda_nodata</code></pre>
</details>
</dd>
<dt id="sertit.rasters.where"><code class="name flex">
<p>def <span class="ident">where</span>(</p><p>cond, <br>if_true, <br>if_false, <br>master_xda=None, <br>new_name='')</p>
</code></dt>
<dd>
<div class="desc"><p>Overloads <code>xr.where</code> with:</p>
<ul>
<li>setting metadata of <code>master_xda</code></li>
<li>preserving the nodata pixels of the <code>master_xda</code></li>
</ul>
<p>If <code>master_xda</code> is None, use it like <code>xr.where</code>.
Else, it outputs a <code>xarray.DataArray</code> with the same dtype than <code>master_xda</code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If you don't give a <code>master_xda</code>,
it is better to pass numpy arrays to <code>if_false</code> and <code>if_true</code> keywords
as passing xarrays interfers with the output metadata (you may lose the CRS and so on).
Just pass <code>if_true=true_xda.data</code> inplace of <code>if_true=true_xda</code> and the same for <code>if_false</code></p>
</div>
<pre><code class="language-python">&gt;&gt;&gt; A = xr.DataArray(dims=(&quot;x&quot;, &quot;y&quot;), data=[[1, 0, 5], [np.nan, 0, 0]])
&gt;&gt;&gt; mask_A = rasters.where(A &gt; 3, 0, 1, A, new_name=&quot;mask_A&quot;)
&lt;xarray.DataArray 'mask_A' (x: 2, y: 3)&gt;
array([[ 1.,  1.,  0.],
       [nan,  1.,  1.]])
Dimensions without coordinates: x, y
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cond</code></strong> :&ensp;<code>scalar, array, Variable, DataArray</code> or <code>Dataset</code></dt>
<dd>Conditional array</dd>
<dt><strong><code>if_true</code></strong> :&ensp;<code>scalar, array, Variable, DataArray</code> or <code>Dataset</code></dt>
<dd>What to do if <code>cond</code> is True</dd>
<dt><strong><code>if_false</code></strong> :&ensp;<code>scalar, array, Variable, DataArray</code> or <code>Dataset</code></dt>
<dd>What to do if <code>cond</code> is False</dd>
<dt><strong><code>master_xda</code></strong></dt>
<dd>Master <code>xr.DataArray</code> used to set the metadata and the nodata</dd>
<dt><strong><code>new_name</code></strong> :&ensp;<code>str</code></dt>
<dd>New name of the array</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xr.DataArray</code></dt>
<dd>Where array with correct mtd and nodata pixels</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def where(
    cond, if_true, if_false, master_xda: xr.DataArray = None, new_name: str = &#34;&#34;
) -&gt; xr.DataArray:
    &#34;&#34;&#34;
    Overloads `xr.where` with:

    - setting metadata of `master_xda`
    - preserving the nodata pixels of the `master_xda`

    If `master_xda` is None, use it like `xr.where`.
    Else, it outputs a `xarray.DataArray` with the same dtype than `master_xda`.

    .. WARNING::
        If you don&#39;t give a `master_xda`,
        it is better to pass numpy arrays to `if_false` and `if_true` keywords
        as passing xarrays interfers with the output metadata (you may lose the CRS and so on).
        Just pass `if_true=true_xda.data` inplace of `if_true=true_xda` and the same for `if_false`

    ```python
    &gt;&gt;&gt; A = xr.DataArray(dims=(&#34;x&#34;, &#34;y&#34;), data=[[1, 0, 5], [np.nan, 0, 0]])
    &gt;&gt;&gt; mask_A = rasters.where(A &gt; 3, 0, 1, A, new_name=&#34;mask_A&#34;)
    &lt;xarray.DataArray &#39;mask_A&#39; (x: 2, y: 3)&gt;
    array([[ 1.,  1.,  0.],
           [nan,  1.,  1.]])
    Dimensions without coordinates: x, y
    ```
    Args:
        cond (scalar, array, Variable, DataArray or Dataset): Conditional array
        if_true (scalar, array, Variable, DataArray or Dataset): What to do if `cond` is True
        if_false (scalar, array, Variable, DataArray or Dataset):  What to do if `cond` is False
        master_xda: Master `xr.DataArray` used to set the metadata and the nodata
        new_name (str): New name of the array

    Returns:
        xr.DataArray: Where array with correct mtd and nodata pixels
    &#34;&#34;&#34;
    # Enforce condition
    where_xda = xr.where(cond, if_true, if_false)

    if master_xda is not None:
        # Convert to master dtype
        if where_xda.dtype != master_xda.dtype:
            where_xda = where_xda.astype(master_xda.dtype)

        # Convert to datarray if needed
        if not isinstance(where_xda, xr.DataArray):
            where_xda = master_xda.copy(data=where_xda)

        # Set nodata to nan
        where_xda = where_xda.where(~np.isnan(master_xda))

        # Set mtd
        where_xda = set_metadata(where_xda, master_xda, new_name=new_name)

    return where_xda</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="Home" href="/sertit-utils/">
<img src="https://sertit.pages.sertit.unistra.fr/sertit-utils/sertit_utils.png"
alt="logo"
style="width:40%;"/>
</a>
</header>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sertit" href="index.html">sertit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="sertit.rasters.LOGGER" href="#sertit.rasters.LOGGER">LOGGER</a></code></li>
<li><code><a title="sertit.rasters.XDS_TYPE" href="#sertit.rasters.XDS_TYPE">XDS_TYPE</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="sertit.rasters.path_xarr_dst" href="#sertit.rasters.path_xarr_dst">path_xarr_dst</a></code></li>
<li><code><a title="sertit.rasters.to_np" href="#sertit.rasters.to_np">to_np</a></code></li>
<li><code><a title="sertit.rasters.get_nodata_mask" href="#sertit.rasters.get_nodata_mask">get_nodata_mask</a></code></li>
<li><code><a title="sertit.rasters.vectorize" href="#sertit.rasters.vectorize">vectorize</a></code></li>
<li><code><a title="sertit.rasters.get_valid_vector" href="#sertit.rasters.get_valid_vector">get_valid_vector</a></code></li>
<li><code><a title="sertit.rasters.get_nodata_vector" href="#sertit.rasters.get_nodata_vector">get_nodata_vector</a></code></li>
<li><code><a title="sertit.rasters.mask" href="#sertit.rasters.mask">mask</a></code></li>
<li><code><a title="sertit.rasters.paint" href="#sertit.rasters.paint">paint</a></code></li>
<li><code><a title="sertit.rasters.crop" href="#sertit.rasters.crop">crop</a></code></li>
<li><code><a title="sertit.rasters.read" href="#sertit.rasters.read">read</a></code></li>
<li><code><a title="sertit.rasters.write" href="#sertit.rasters.write">write</a></code></li>
<li><code><a title="sertit.rasters.collocate" href="#sertit.rasters.collocate">collocate</a></code></li>
<li><code><a title="sertit.rasters.sieve" href="#sertit.rasters.sieve">sieve</a></code></li>
<li><code><a title="sertit.rasters.get_dim_img_path" href="#sertit.rasters.get_dim_img_path">get_dim_img_path</a></code></li>
<li><code><a title="sertit.rasters.get_extent" href="#sertit.rasters.get_extent">get_extent</a></code></li>
<li><code><a title="sertit.rasters.get_footprint" href="#sertit.rasters.get_footprint">get_footprint</a></code></li>
<li><code><a title="sertit.rasters.merge_vrt" href="#sertit.rasters.merge_vrt">merge_vrt</a></code></li>
<li><code><a title="sertit.rasters.merge_gtiff" href="#sertit.rasters.merge_gtiff">merge_gtiff</a></code></li>
<li><code><a title="sertit.rasters.unpackbits" href="#sertit.rasters.unpackbits">unpackbits</a></code></li>
<li><code><a title="sertit.rasters.read_bit_array" href="#sertit.rasters.read_bit_array">read_bit_array</a></code></li>
<li><code><a title="sertit.rasters.read_uint8_array" href="#sertit.rasters.read_uint8_array">read_uint8_array</a></code></li>
<li><code><a title="sertit.rasters.set_metadata" href="#sertit.rasters.set_metadata">set_metadata</a></code></li>
<li><code><a title="sertit.rasters.set_nodata" href="#sertit.rasters.set_nodata">set_nodata</a></code></li>
<li><code><a title="sertit.rasters.where" href="#sertit.rasters.where">where</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>