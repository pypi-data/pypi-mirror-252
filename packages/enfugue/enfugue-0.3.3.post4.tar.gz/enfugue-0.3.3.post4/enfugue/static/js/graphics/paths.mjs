import{Point,Drawable,Vector,CardinalDirection}from"./geometry.mjs";class PathFinder{static stepSizes=[25,5,1];static maximumIterations=1e3;static obstacleBerth=1;constructor(t=[]){this.obstacles=t}find(t,e){let i=0,a=this.constructor.stepSizes[i],r=(this.constructor.obstacleBerth,t.clone()),s=e.clone(),o=r.clone(),n=[t],c=new Vector(r,e),l=c.estimateCardinal(a),h=!1,x=0,u={};for(;!h;){let t=!1;for(;!t;){switch(o.copy(r),l){case CardinalDirection.NORTH:o.y-=a,t=o.y<s.y;break;case CardinalDirection.NORTHEAST:o.y-=a,o.x+=a,t=o.y<s.y||o.x>s.x;break;case CardinalDirection.EAST:o.x+=a,t=o.x>s.x;break;case CardinalDirection.SOUTHEAST:o.x+=a,o.y+=a,t=o.y>s.y||o.x>s.x;break;case CardinalDirection.SOUTH:o.y+=a,t=o.y>s.y;break;case CardinalDirection.SOUTHWEST:o.x-=a,o.y+=a,t=o.x<s.x||o.y>s.y;break;case CardinalDirection.WEST:o.x-=a,t=o.x<s.x;break;case CardinalDirection.NORTHWEST:o.y-=a,o.x-=a,t=o.y<s.y||o.x<s.x}if(t)i<this.constructor.stepSizes.length-1&&(t=!1,a=this.constructor.stepSizes[++i]);else{let t=null;for(let e=0;e<this.obstacles.length;e++)if(!(void 0!==u[e]&&u[e].length>=3)&&this.obstacles[e].containsBounding(o,!1)){t=e;break}if(null!==t){let e=this.obstacles[t].extremes,i=n[n.length-1],o=-1,c=null,h=void 0!==u[t],x=h?s:i;for(let i=0;i<e.length;i++){if(h&&-1!==u[t].indexOf(i))continue;let a=e[i],r=x.distanceTo(a);(null===c||r<c)&&(o=i,c=r)}void 0===u[t]&&(u[t]=[]),u[t].push(o);let y=e[o];s.copy(y),r.copy(i),l=new Vector(r,s).estimateCardinal(a)}else r.copy(o)}if(!t&&x++>=this.constructor.maximumIterations)throw"Maximum iterations reached."}if(h=r.equals(e,2*a),h||(i=0,a=this.constructor.stepSizes[0],n.push(r.clone()),r.equals(s)?(s.copy(e),c.start.copy(r),l=c.estimateCardinal(a)):l=new Vector(r,s).estimateCardinal(1)),!h&&x++>=this.constructor.maximumIterations)throw"Maximum iterations reached."}return n.push(e),n}}export{PathFinder};
