import{isEmpty,deepClone,sleep}from"../base/helpers.mjs";import{View}from"../view/base.mjs";import{Point,Drawable,Vector,CardinalDirection}from"../graphics/geometry.mjs";import{PathFinder}from"../graphics/paths.mjs";import{SplinePoint,Spline}from"../graphics/spline.mjs";const splineHideAlpha=.25,splineShowAlpha=.5,frameDelay=50,timedDrawDelay=1e3;class NodeConnectionSpline extends Spline{static lineJoin="miter";constructor(t,i,e,s,h){super(t),this.width=i,this.shrink=e,this.rgb=s,this.a=.25,this.exclusions=h}set fixed(t){this.a=t?.5:.25}get start(){return this.points[0]}get end(){return this.points[this.points.length-1]}set start(t){this.start.x=Math.round(t.x),this.start.y=Math.round(t.y),this.recalculate()}set end(t){this.end.x=Math.round(t.x),this.end.y=Math.round(t.y),this.recalculate()}set rgb(t){[this.r,this.g,this.b]=t}exclude(t){this.exclusions=t,this.recalculate()}recalculate(){try{let t=this.start.anchorPoint,i=this.end.anchorPoint,e=t.clone().add(new Point(this.width,0)),s=i.clone().subtract(new Point(this.width,0)),h=[t,...new PathFinder(this.exclusions).find(e,s),i];this.points=h.map((t=>new SplinePoint(t,SplinePoint.TYPE_LINEAR)))}catch(t){}}stroke(t){this.drawPath(t),t.lineJoin=this.constructor.lineJoin,t.lineWidth=this.width-this.shrink,t.strokeStyle=`rgba(${this.r},${this.g},${this.b},${this.a})`,t.stroke();let i=this.points[0],e=this.points[this.points.length-1],s=[new Point(i.x,i.y-this.shrink),new Point(i.x,i.y-1.5*this.shrink),new Point(i.x+this.shrink/2,i.y-this.shrink)],h=[new Point(i.x,i.y+this.shrink),new Point(i.x,i.y+1.5*this.shrink),new Point(i.x+this.shrink/2,i.y+this.shrink)],n=[new Point(e.x,e.y-this.shrink),new Point(e.x,e.y-1.5*this.shrink),new Point(e.x-this.shrink/2,e.y-this.shrink)],o=[new Point(e.x,e.y+this.shrink),new Point(e.x,e.y+1.5*this.shrink),new Point(e.x-this.shrink/2,e.y+this.shrink)];for(let[i,e,r]of[s,h,n,o])t.beginPath(),t.moveTo(i.x,i.y),t.lineTo(e.x,e.y),t.lineTo(r.x,r.y),t.fillStyle=`rgba(${this.r},${this.g},${this.b},${this.a})`,t.fill()}}class NodeEditorDecorationsView extends View{static tagName="canvas";constructor(t,i,e,s,h){super(t),this.editor=i,this.width=e,this.height=s,this.splines=[],this.startTimer()}get exclusions(){return this.editor.nodes.map((t=>t.drawable))}recalculate(){let t=this.exclusions;for(let i of this.splines)i.exclude(t)}draw(){if(void 0!==this.node){if(void 0===this.node.element)return;let t=this.node.element.getContext("2d");t.clearRect(0,0,this.width,this.height);for(let i of this.splines)i.stroke(t)}}startTimer(){let t;void 0!==this.node&&void 0!==this.node.element&&(t=!0,this.executeTimer()),t||setTimeout((()=>this.startTimer()),50)}executeTimer(){void 0!==this.node&&void 0!==this.node.element&&document.documentElement.contains(this.node.element)&&(this.draw(),setTimeout((()=>this.executeTimer()),1e3))}add(t,i,e,s){let h=new SplinePoint(t,SplinePoint.TYPE_LINEAR),n=new NodeConnectionSpline([h,h.clone()],i,e,s,this.exclusions);return this.splines.push(n),n}remove(t){this.splines=this.splines.filter((i=>i!=t))}setDimension(t,i){this.width=t,this.height=i,void 0!==this.node&&this.node.height(this.height).width(this.width).css({height:`${this.height}px`,width:`${this.width}px`})}async build(){let t=await super.build();return t.height(this.height).width(this.width).css({height:`${this.height}px`,width:`${this.width}px`}),t}}export{NodeEditorDecorationsView,NodeConnectionSpline};
