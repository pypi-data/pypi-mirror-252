import{View}from"./base.mjs";import{Point,Drawable,Vector}from"../graphics/geometry.mjs";import{Spline,SplinePoint}from"../graphics/spline.mjs";import{ElementBuilder}from"../base/builder.mjs";import{isEmpty,deepClone,isEquivalent,bindPointerUntilRelease,getPointerEventCoordinates}from"../base/helpers.mjs";const E=new ElementBuilder;class EditableSplineVector extends Spline{static handleWidth=10;static arrowLength=10;getHandleAboutPoint(t,e=0){return new Drawable([new Point(t.x-this.constructor.handleWidth-e,t.y-this.constructor.handleWidth-e),new Point(t.x+this.constructor.handleWidth+e,t.y-this.constructor.handleWidth-e),new Point(t.x+this.constructor.handleWidth+e,t.y+this.constructor.handleWidth+e),new Point(t.x-this.constructor.handleWidth-e,t.y+this.constructor.handleWidth+e),new Point(t.x-this.constructor.handleWidth-e,t.y-this.constructor.handleWidth-e)])}quadraticBezierCurvePoint(t,e,i,n){const s=(1-(n=Math.max(0,Math.min(1,n))))*(1-n),o=2*(1-n)*n,l=n*n,h=s*t.x+o*e.x+l*i.x,r=s*t.y+o*e.y+l*i.y;return new Point(h,r)}cubicBezierCurvePoint(t,e,i,n,s){s=Math.max(0,Math.min(1,s));const o=Math.pow(1-s,3),l=3*Math.pow(1-s,2)*s,h=3*(1-s)*Math.pow(s,2),r=Math.pow(s,3),a=o*t.x+l*e.x+h*i.x+r*n.x,c=o*t.y+l*e.y+h*i.y+r*n.y;return new Point(a,c)}removePoint(t){this.points=this.points.slice(0,t).concat(this.points.slice(t+1))}addPoint(t){let e,i=this.points[t-1],n=this.points[t];e=i.pointType===SplinePoint.TYPE_LINEAR&&n.pointType===SplinePoint.TYPE_BEZIER?this.quadraticBezierCurvePoint(i,n.controlPoint1,n,.5):i.pointType===SplinePoint.TYPE_BEZIER&&n.pointType===SplinePoint.TYPE_LINEAR?this.quadraticBezierCurvePoint(i,i.controlPoint2,n,.5):i.pointType!==SplinePoint.TYPE_LINEAR&&n.pointType!==SplinePoint.TYPE_LINEAR?this.cubicBezierCurvePoint(i,i.controlPoint2,n.controlPoint1,n,.5):new Vector(i,n).halfway,this.points=this.points.slice(0,t).concat([new SplinePoint(e,SplinePoint.TYPE_LINEAR)]).concat(this.points.slice(t))}getEndingAngleBetweenPoints(t,e){return t=t.clone(),e=e.clone(),t.pointType===SplinePoint.TYPE_LINEAR&&e.pointType===SplinePoint.TYPE_BEZIER?t=this.quadraticBezierCurvePoint(t,e.controlPoint1,e,.9):t.pointType===SplinePoint.TYPE_BEZIER&&e.pointType===SplinePoint.TYPE_LINEAR?t=this.quadraticBezierCurvePoint(t,t.controlPoint2,e,.9):t.pointType!==SplinePoint.TYPE_LINEAR&&e.pointType!==SplinePoint.TYPE_LINEAR&&(t=this.cubicBezierCurvePoint(t,t.controlPoint2,e.controlPoint1,e,.9)),new Vector(t,e).rad+3*Math.PI/2}draw(t,e,i,n){t.strokeStyle=e,t.fillStyle=e,t.lineWidth=2,this.stroke(t);let[s,o]=this.points.slice(-2),l=new Drawable([new Point(o.x,o.y),new Point(o.x-this.constructor.arrowLength,o.y-this.constructor.arrowLength),new Point(o.x+this.constructor.arrowLength,o.y-this.constructor.arrowLength),new Point(o.x,o.y)]);if(l.rotateAbout(this.getEndingAngleBetweenPoints(s,o),o),l.fill(t),i){t.fillStyle="rgba(0,0,0,0.4)";for(let i in this.points){let s=this.points[i],o=[];isEmpty(n)||isEmpty(n[i])||(o=n[i]);let l=this.getHandleAboutPoint(s);if(t.lineWidth=2,t.strokeStyle=-1!==o.indexOf("anchorPoint")?e:"#ffffff",l.stroke(t),l.fill(t),t.lineWidth=1,s.pointType===SplinePoint.TYPE_BEZIER){if(!isEmpty(s.controlPoint1)){let i=this.getHandleAboutPoint(s.controlPoint1,-2),n=new Drawable([s.anchorPoint,s.controlPoint1]);t.strokeStyle=-1!==o.indexOf("controlPoint1")?e:"#ffffff",t.setLineDash([]),i.stroke(t),t.setLineDash([4,2]),n.stroke(t)}if(!isEmpty(s.controlPoint2)){let i=this.getHandleAboutPoint(s.controlPoint2,-2),n=new Drawable([s.anchorPoint,s.controlPoint2]);t.strokeStyle=-1!==o.indexOf("controlPoint2")?e:"#ffffff",t.setLineDash([]),i.stroke(t),t.setLineDash([4,2]),n.stroke(t)}}t.setLineDash([])}}}}class VectorCursorMode{static NONE=0;static MOVE=1;static ROTATE=2;static SELECT=3}class VectorView extends View{static tagName="enfugue-vector-view";static historyLength=250;constructor(t,e,i){super(t),this.width=e,this.height=i,this.splines=[],this.onChangeCallbacks=[],this.canvas=document.createElement("canvas"),this.canvas.width=e,this.canvas.height=i,this.mode=VectorCursorMode.NONE,this.selected={},this.startPosition=null,this.startSelected=null,this.startRadians=null,this.extendCopies=2,this.history=[],this.redoStack=[]}getValueFromSpline(t){return t.points.map((t=>{let e={anchor:[t.x,t.y]};return t.pointType===SplinePoint.TYPE_BEZIER&&(isEmpty(t.controlPoint1)||(e.control_1=[t.cp1x,t.cp1y]),isEmpty(t.controlPoint2)||(e.control_2=[t.cp2x,t.cp2y])),e}))}get value(){return this.splines.map((t=>this.getValueFromSpline(t)))}get extendedValue(){return this.splines.map((t=>{let e=this.getValueFromSpline(t);for(let i=0;i<this.extendCopies;i++){let i=t.clone(),n=t.points[0],[s,o]=t.points.slice(-2),l=o.x-n.x,h=o.y-n.y;i.translatePoint(new Point(l,h));let r=this.getValueFromSpline(i);e[e.length-1].control_2=r[0].control_1,e=e.concat(r.slice(1)),t=i}return e}))}set value(t){this.splines=t.map((t=>new EditableSplineVector(t.map((t=>{let e=new Point(t.anchor[0],t.anchor[1]),i=isEmpty(t.control_1)&&isEmpty(t.control_2)?SplinePoint.TYPE_LINEAR:SplinePoint.TYPE_BEZIER,n=isEmpty(t.control_1)?void 0:new Point(t.control_1[0],t.control_1[1]),s=isEmpty(t.control_2)?void 0:new Point(t.control_2[0],t.control_2[1]);return new SplinePoint(e,i,n,s)}))))),this.updateCanvas()}get color(){return window.getComputedStyle(document.documentElement).getPropertyValue("--theme-color-primary")}onChange(t){this.onChangeCallbacks.push(t)}changed(t=!0,e=!0){let i=this.value,n=this.lastCallbackValue;if(!isEquivalent(i,n)){for(let t of this.onChangeCallbacks)t(i);t&&(this.history=this.history.concat([i]).slice(-this.constructor.historyLength),e&&(this.redoStack=[]))}this.lastCallbackValue=i}undo(){if(!isEmpty(this.history)){let t=this.history.pop(-1);this.redoStack.push(t),this.value=this.history[this.history.length-1],this.changed(!1,!1)}}redo(){if(!isEmpty(this.redoStack)){let t=this.redoStack.pop(-1);this.value=t,this.changed(!0,!1)}}resizeCanvas(t,e){this.width=t,this.height=e,this.canvas.width=t,this.canvas.height=e;for(let i of this.splines)for(let n of i.points)n.x=Math.min(n.x,t),n.y=Math.min(n.y,e),isEmpty(n.controlPoint1)||(n.cp1x=Math.min(n.cp1x,t),n.cp1y=Math.min(n.cp1y,e)),isEmpty(n.controlPoint2)||(n.cp2x=Math.min(n.cp2x,t),n.cp2y=Math.min(n.cp2y,e));this.updateCanvas(),this.changed()}updateCanvas(){let t=this.canvas.getContext("2d"),e=this.color;t.clearRect(0,0,this.width,this.height);for(let i in this.splines){let n=this.splines[i];n.draw(t,e,!0,this.selected[i]);for(let i=0;i<this.extendCopies;i++){let i=n.clone(),s=n.points[0],[o,l]=n.points.slice(-2),h=l.x-s.x,r=l.y-s.y;i.translatePoint(new Point(h,r)),t.setLineDash([2,4]),i.draw(t,e,!1),n=i}t.setLineDash([])}}setCopies(t){this.extendCopies=t,this.updateCanvas()}getCoordinates(t){if(t.touches&&t.touches.length>0){let e=t.target.getBoundingClientRect();return[t.touches[0].clientX-e.x,t.touches[0].clientY-e.y]}return[t.offsetX,t.offsetY]}getPointFromCoordinates(t,e){for(let i in this.splines){let n=this.splines[i];for(let s in n.points){let o=n.points[s];for(let n of["anchorPoint","controlPoint1","controlPoint2"])if(!isEmpty(o[n])&&o[n].x-EditableSplineVector.handleWidth<=t&&o[n].x+EditableSplineVector.handleWidth>t&&o[n].y-EditableSplineVector.handleWidth<=e&&o[n].y+EditableSplineVector.handleWidth>e)return[parseInt(i),parseInt(s),n]}}}getSplineFromCoordinates(t,e){let i=new Point(t,e);for(let t in this.splines){let e=this.splines[t].pointAlongSpline(i,10);if(!isEmpty(e))return[parseInt(t),e+1]}}onNodeMouseDown(t){if("mousedown"===t.type&&1!==t.which)return;if(t.metaKey||t.ctrlKey&&!t.shiftKey)return;t.preventDefault(),t.stopPropagation();let[e,i]=this.getCoordinates(t);try{let n=this.getPointFromCoordinates(e,i);if(!isEmpty(n)){let[e,i,s]=n;if(t.altKey&&"anchorPoint"===s)2===this.splines[e].points.length?this.splines=this.splines.slice(0,e).concat(this.splines.slice(e+1)):this.splines[e].removePoint(i);else{t.shiftKey||(this.selected={}),isEmpty(this.selected[e])&&(this.selected[e]={}),isEmpty(this.selected[e][i])&&(this.selected[e][i]=[]),-1!==this.selected[e][i].indexOf(s)||this.selected[e][i].push(s),this.mode=VectorCursorMode.MOVE}return}let s=this.getSplineFromCoordinates(e,i);if(!isEmpty(s)){let[e,i]=s;if(t.altKey)this.splines[e].addPoint(i);else{t.shiftKey||(this.selected={}),this.selected[e]={};for(let t in this.splines[e].points){let i=["anchorPoint"];for(let n of["controlPoint1","controlPoint2"])isEmpty(this.splines[e].points[t][n])||i.push(n);this.selected[e][t]=i}this.mode=VectorCursorMode.MOVE}return}if(t.altKey){let t=new EditableSplineVector([new SplinePoint(new Point(e,i),SplinePoint.TYPE_LINEAR),new SplinePoint(new Point(e,i),SplinePoint.TYPE_LINEAR)]);this.splines.push(t),this.selected={},this.selected[this.splines.length-1]={},this.selected[this.splines.length-1][1]=["anchorPoint"],this.mode=VectorCursorMode.MOVE}else t.shiftKey&&t.ctrlKey?this.mode=VectorCursorMode.ROTATE:(this.startSelected=deepClone(this.selected),this.mode=VectorCursorMode.SELECT)}finally{this.mode!==VectorCursorMode.NONE&&(this.startPosition=[e,i]),this.updateCanvas(),this.changed()}}onNodeMouseUp(t){this.mode=VectorCursorMode.NONE,this.startPosition=null,this.startSelected=null,this.startRadians=null,this.updateCanvas(),this.changed()}rectangleSelect(t,e=!1){let[[i,n],[s,o]]=t,l=Math.min(i,s),h=Math.max(i,s),r=Math.min(n,o),a=Math.max(n,o),c=new Drawable([new Point(l,r),new Point(h,r),new Point(h,a),new Point(l,a),new Point(l,r)]),p=this.canvas.getContext("2d"),d={};e&&!isEmpty(this.startSelected)&&(d=deepClone(this.startSelected));for(let t in this.splines){isEmpty(d[t])&&(d[t]={});for(let e in this.splines[t].points){let i=this.splines[t].points[e];isEmpty(d[t][e])&&(d[t][e]=[]);for(let n of["anchorPoint","controlPoint1","controlPoint2"])-1===d[t][e].indexOf(n)&&!isEmpty(i[n])&&c.containsBounding(i[n])&&d[t][e].push(n);isEmpty(d[t][e])&&delete d[t][e]}isEmpty(d[t])&&delete d[t]}this.selected=d,this.updateCanvas(),p.setLineDash([4,2]),p.lineWidth=2,p.strokeStyle="#ffffff",c.stroke(p),p.setLineDash([])}getSelectedPoints(){let t=[];for(let e in this.selected)for(let i in this.selected[e])for(let n of this.selected[e][i])isEmpty(this.splines[e].points[i][n])||t.push(this.splines[e].points[i][n]);return t}copySelected(t=25){let e={};for(let i in this.selected){let n=[];for(let t in this.selected[i])-1!==this.selected[i][t].indexOf("anchorPoint")&&n.push(this.splines[i].points[t]);if(n.length>=2){let i=n.map((e=>((e=e.clone()).x=Math.min(e.x+t,this.width),e.y=Math.min(e.y+t,this.height),isEmpty(e.controlPoint1)||(e.cp1x=Math.min(e.cp1x+t,this.width),e.cp1y=Math.min(e.cp1y+t,this.height)),isEmpty(e.controlPoint2)||(e.cp2x=Math.min(e.cp2x+t,this.width),e.cp2y=Math.min(e.cp2y+t,this.height)),e))),s=new EditableSplineVector(i);this.splines.push(s),e[this.splines.length-1]={};for(let t in s.points){e[this.splines.length-1][t]=[];for(let i of["anchorPoint","controlPoint1","controlPoint2"])isEmpty(s.points[t][i])||e[this.splines.length-1][t].push(i)}}}isEmpty(e)||(this.selected=e),this.updateCanvas(),this.changed()}deleteSelected(){for(let t in this.selected){for(let e in this.selected[t])-1!==this.selected[t][e].indexOf("anchorPoint")&&(this.splines[t].points[e]=null);this.splines[t].points=this.splines[t].points.filter((t=>null!==t)),this.splines[t].points.length<2&&(this.splines[t]=null)}this.splines=this.splines.filter((t=>null!==t)),this.selected={},this.updateCanvas(),this.changed()}onNodeMouseMove(t){let[e,i]=this.getCoordinates(t);switch(this.mode){case VectorCursorMode.MOVE:let[n,s]=this.startPosition,[o,l]=[n-e,s-i];for(let t of this.getSelectedPoints())t.x-=o,t.y-=l;this.startPosition=[e,i],this.updateCanvas();break;case VectorCursorMode.ROTATE:let h=new Drawable(this.getSelectedPoints()),r=new Point(e,i),a=new Point(...this.startPosition),c=new Vector(r,h.center),p=new Vector(a,h.center),d=c.radians-p.radians;h.rotate(d),this.updateCanvas(),this.startPosition=[e,i];break;case VectorCursorMode.SELECT:this.rectangleSelect([this.startPosition,[e,i]],t.shiftKey);break;case VectorCursorMode.NONE:isEmpty(this.getPointFromCoordinates(e,i))?isEmpty(this.getSplineFromCoordinates(e,i))?this.node.css("cursor","default"):this.node.css("cursor","cell"):this.node.css("cursor","pointer")}}onDblClick(t){let[e,i]=this.getCoordinates(t),n=this.getPointFromCoordinates(e,i);if(!isEmpty(n)){let[t,e]=n,i=this.splines[t].points[e];if(i.pointType===SplinePoint.TYPE_LINEAR){if(0===e){let e=new Vector(...this.splines[t].points.slice(0,2));i.controlPoint2=e.halfway}else if(e===this.splines[t].points.length-1){let n=new Vector(...this.splines[t].points.slice(e-1,e+1));i.controlPoint1=n.halfway}else{let n=new Vector(...this.splines[t].points.slice(e,e+2)),s=new Vector(...this.splines[t].points.slice(e-1,e+1));i.controlPoint1=s.halfway,i.controlPoint2=n.halfway}i.pointType=SplinePoint.TYPE_BEZIER}else i.pointType=SplinePoint.TYPE_LINEAR,delete i.controlPoint1,delete i.controlPoint2;this.updateCanvas(),this.changed()}}async build(){let t=await super.build();return t.append(this.canvas),t.on("dblclick",(t=>this.onDblClick(t))),t.on("mousemove",(t=>this.onNodeMouseMove(t)),!0),t.on("mousedown",(t=>this.onNodeMouseDown(t))),t.on("mouseup",(t=>this.onNodeMouseUp(t))),t.on("touchstart",(t=>this.onNodeMouseDown(t,!0))),t.on("touchmove",(t=>this.onNodeMouseMove(t)),!0),t.on("touchend",(t=>this.onNodeMouseUp(t))),this.updateCanvas(),t}}export{VectorView};
