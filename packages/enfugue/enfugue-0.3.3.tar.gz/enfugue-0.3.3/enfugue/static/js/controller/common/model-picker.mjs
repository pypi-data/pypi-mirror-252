import{isEmpty,waitFor}from"../../base/helpers.mjs";import{ElementBuilder}from"../../base/builder.mjs";import{Controller}from"../base.mjs";import{TableView}from"../../view/table.mjs";import{View}from"../../view/base.mjs";import{FormView}from"../../forms/base.mjs";import{ModelPickerInputView}from"../../forms/input/enfugue/models.mjs";import{AbridgedModelFormView}from"../../forms/enfugue/models.mjs";const E=new ElementBuilder;class ModelTensorRTTableView extends TableView{static canSort=!1;static columnFormatters={Build:function(e,t){if(!0===e)return E.span().content("Ready");{let i=E.button().content("Build").on("click",(async()=>{try{i.disabled(!0).addClass("loading-bar loading"),await this.buildEngine(t),i.removeClass("loading-bar").removeClass("loading").content("Ready")}catch(e){i.removeClass("loading-bar loading").disabled(!1)}}));return"building"===e&&i.disabled(!0).addClass("loading-bar loading"),i}}};constructor(e,t,i){super(e,t),this.buildEngine=i}}class ModelTensorRTStatusView extends View{static tagName="enfugue-tensorrt-status-view";static supportedNetworks={unet:"UNet",controlled_unet:"Controlled UNet",inpaint_unet:"Inpainting UNet"};static tensorRTDescription=["TensorRT is a technology created by Nvidia that transforms an AI model into one that takes advantage of hardware acceleration available on Nvidia GPUs.","As there are numerous varying architectures used by Nvidia that support this technology, these engines must be compiled by an architecture compatible with your actual hardware, rather than distributed by AI model providers.","The compilation time for each model varies, but generally takes between 15 and 30 minutes each. You can expect between 50% and 100% faster inference speeds during the engine's respective step(s).","The compiled engine is only useable for a model with the same checkpoint, LoRA, LyCORIS, Textual Inversion and engine size. If you change any of those details about this model, it will require recompilation. You can safely change model prompts as desired without requiring a new engine."];static networkDescriptions={unet:"The network used when creating images with a prompt or base image.",controlled_unet:"The network used when creating images with a control image.",inpaint_unet:"The network used when inpainting or outpainting."};constructor(e,t,i){super(e),this.status=t,this.buildEngine=i}get tableData(){return Object.getOwnPropertyNames(this.constructor.supportedNetworks).map((e=>({"Network Name":this.constructor.supportedNetworks[e],Description:this.constructor.networkDescriptions[e],Build:this.status.building===e?"building":this.status[`${e}_ready`]})))}getNameFromLabel(e){for(let t in this.constructor.supportedNetworks)if(this.constructor.supportedNetworks[t]===e)return t;throw`Unknown network ${e}`}async build(){let e=await super.build(),t=new ModelTensorRTTableView(this.config,this.tableData,(e=>this.buildEngine(this.getNameFromLabel(e["Network Name"]))));for(let t of this.constructor.tensorRTDescription)e.append(E.p().class("margin").content(t));return e.append(await t.getNode())}}class ModelPickerFormView extends FormView{static className="model-picker";static autoSubmit=!0;static fieldSets={Model:{model:{class:ModelPickerInputView}}};static tensorRTLogo="/static/img/brand/tensorrt.png";setTensorRTStatus(e,t){let i=this.node.find("#tensorrt");if(e.supported){let o=ModelTensorRTStatusView.supportedNetworks,s=Object.getOwnPropertyNames(o),n=s.length,r=s.reduce(((t,i)=>(t[i]=e[`${i}_ready`],t)),{}),a=Object.values(r).filter((e=>e)).length;isEmpty(i)?(i=E.div().id("tensorrt").append(E.img().src(this.constructor.tensorRTLogo),E.span().class("fraction").content(E.span().content(`${a}`),E.span().content(`${n}`))).on("click",(()=>t())),this.node.append(i)):i.off("click").on("click",(()=>t())).find("span.fraction").content(E.span().content(`${a}`),E.span().content(`${n}`)),e.ready?i.addClass("ready").data("tooltip","TensorRT is <strong>ready</strong>"):i.removeClass("ready").data("tooltip","TensorRT is <strong>not ready</strong>")}else isEmpty(i)||this.node.remove(i)}}class ModelPickerFormsView extends View{static tagName="enfugue-model-picker";static showMoreText="More Model Configuration";constructor(e,t,i){super(e),this.pickerForm=t,this.onShowMore=i}async build(){let e=await super.build(),t=E.button().content(this.constructor.showMoreText).on("click",(e=>{e.stopPropagation(),this.onShowMore()}));return e.content(await this.pickerForm.getNode(),t),e}}class ModelPickerController extends Controller{static tensorRTStatusWindowWidth=500;static tensorRTStatusWindowHeight=750;static modelWindowWidth=500;static modelWindowHeight=500;static modelWindowTitle="More Model Configuration";getState(e=!0){return{model:this.modelPickerFormView.values,modelConfig:this.abridgedModelFormView.values}}getDefaultState(){return{model:null,modelConfig:null}}setState(e){isEmpty(e.model)||(this.modelPickerFormView.suppressDefaults=!0,this.modelPickerFormView.setValues(e.model,!1).then((()=>this.modelPickerFormView.submit()))),isEmpty(e.modelConfig)||this.abridgedModelFormView.setValues(e.modelConfig).then(setTimeout((()=>this.abridgedModelFormView.submit()),250))}async buildEngine(e,t){await this.model.post(`/models/${e}/tensorrt/${t}`),this.notify("info","Build Started","The engine will be busy throughout this TensorRT build. You will see a notification when it is complete, and the status indicator in the top bar will show ready or idle."),await waitFor((()=>!isEmpty(this.builtEngines[e])&&-1!==this.builtEngines[e].indexOf(t)),{interval:5e3})}async showBuildTensorRT(e){let t=await e.getStatus(),i=await this.getCurrentEngineBuildProcess(),o={supported:!1};isEmpty(t.tensorrt)||(o=t.tensorrt.base,isEmpty(t.tensorrt.inpainter)||(o.inpaint_unet_ready=t.tensorrt.inpainter.unet_ready)),isEmpty(i)||i.metadata.tensorrt_build.model!==e.name||(t.building=i.metadata.tensorrt_build.network);let s=new ModelTensorRTStatusView(this.config,o,(t=>this.buildEngine(e.name,t)));return await this.spawnWindow(`${e.name} TensorRT Status`,s,this.constructor.tensorRTStatusWindowWidth,this.constructor.tensorRTStatusWindowHeight)}async getCurrentEngineBuildProcess(){let e=await this.model.get("/invocation");for(let t of e)if(void 0!==t.metadata&&void 0!==t.metadata.tensorrt_build&&-1!==["queued","processing"].indexOf(t.status))return t;return null}async showModelForm(){if("model"===this.engine.modelType){let e=await this.model.DiffusionModel.query({name:this.engine.model});this.application.modelManager.showEditModel(e)}else isEmpty(this.modelFormWindow)?(this.modelFormWindow=await this.spawnWindow(this.constructor.modelWindowTitle,this.abridgedModelFormView,this.constructor.modelWindowWidth,this.constructor.modelWindowHeight),this.modelFormWindow.onClose((()=>{delete this.modelFormWindow})),setTimeout((()=>{this.abridgedModelFormView.setValues(this.abridgedModelFormView.values)}),100)):this.modelFormWindow.focus()}async initialize(){this.xl=!1,this.builtEngines={},this.modelPickerFormView=new ModelPickerFormView(this.config),this.abridgedModelFormView=new AbridgedModelFormView(this.config),this.formsView=new ModelPickerFormsView(this.config,this.modelPickerFormView,(()=>this.showModelForm())),this.modelPickerFormView.onSubmit((async e=>{let t=this.modelPickerFormView.suppressDefaults;if(this.modelPickerFormView.suppressDefaults=!1,e.model){let[i,o]=e.model.split("/");if(this.engine.model=o,this.engine.modelType=i,"model"===i)try{let e=await this.model.DiffusionModel.query({name:o}),i=await e.getStatus(),s={supported:!1};e.status=i,t&&(e._relationships.config=null,e._relationships.scheduler=null),this.publish("modelPickerChange",e),isEmpty(i.tensorrt)||(s=i.tensorrt.base,isEmpty(i.tensorrt.inpainter)||(s.inpaint_unet_ready=i.tensorrt.inpainter.unet_ready)),this.modelPickerFormView.setTensorRTStatus(s,(()=>this.showBuildTensorRT(e)))}catch(e){this.modelPickerFormView.setValues({model:null}),console.error(e)}else try{let e=await this.model.get(`/models/${o}/status`);isEmpty(e.metadata.base)||(e.metadata.base.inpainter&&this.notify("warn","Unexpected Configuration","You've selected an inpainting model as your base model. This will work as expected for inpainting, but if you aren't inpainting, results will be poorer than desired. Expand 'Additional Models' and put your model under 'Inpainting Checkpoint' to only use it when inpainting."),e.metadata.base.refiner&&this.notify("warn","Unexpected Configuration","You've selected a refining model as your base model. This will work as expected for refining, but if you aren't refining, results will be poorer than desired. Expand 'Additional Models' and put your model under 'Refining Checkpoint' to only use it when refining.")),this.abridgedModelFormView.submit(),e.refiner=this.abridgedModelFormView.values.refiner,e.inpainter=this.abridgedModelFormView.values.inpainter,this.modelPickerFormView.setTensorRTStatus({supported:!1}),this.publish("modelPickerChange",{status:e,defaultConfiguration:{}})}catch(e){let t="This model's metadata could not be read. It may still work, but it's possible the file is corrupt or otherwise unsupported.";isEmpty(e.title)?console.error(e):(t+=` The error was: ${e.title}`,isEmpty(e.detail)||(t+=`(${e.detail})`)),this.notify("warn","Metadata Error",t)}}else this.modelPickerFormView.setTensorRTStatus({supported:!1})})),this.abridgedModelFormView.onSubmit((async e=>{this.engine.lora=e.lora,this.engine.lycoris=e.lycoris,this.engine.inversion=e.inversion,this.engine.vae=e.vae,this.engine.refiner=e.refiner,this.engine.refinerVae=e.refiner_vae,this.engine.inpainter=e.inpainter,this.engine.inpainterVae=e.inpainter_vae,this.engine.motionModule=e.motion_module,this.abridgedModelFormView.enable(),isEmpty(this.modelFormWindow)||this.modelFormWindow.remove()})),this.abridgedModelFormView.onChange((async()=>{isEmpty(this.abridgedModelFormView.values.refiner)?this.abridgedModelFormView.removeClass("show-refiner"):this.abridgedModelFormView.addClass("show-refiner"),isEmpty(this.abridgedModelFormView.values.inpainter)?this.abridgedModelFormView.removeClass("show-inpainter"):this.abridgedModelFormView.addClass("show-inpainter")})),this.application.container.appendChild(await this.formsView.render()),this.subscribe("invocationError",(e=>{if(!isEmpty(e.metadata)&&!isEmpty(e.metadata.tensorrt_build)){let t=e.metadata.tensorrt_build.network,i=ModelTensorRTStatusView.supportedNetworks[t],o=e.metadata.tensorrt_build.model;this.notify("info","TensorRT Engine Build Failed",`${o} ${i} TensorRT Engine failed to build. Please try again.`)}})),this.subscribe("reInitializeModel",(()=>{this.modelPickerFormView.submit()})),this.subscribe("invocationComplete",(e=>{if(!isEmpty(e.metadata)&&!isEmpty(e.metadata.tensorrt_build)){let t=e.metadata.tensorrt_build.network,i=ModelTensorRTStatusView.supportedNetworks[t],o=e.metadata.tensorrt_build.model;this.notify("info","TensorRT Engine Build Complete",`Successfully built ${o} ${i} TensorRT Engine.`),isEmpty(this.builtEngines[o])&&(this.builtEngines[o]=[]),this.builtEngines[o].push(t)}}))}}export{ModelPickerController};
