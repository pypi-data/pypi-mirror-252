Metadata-Version: 2.1
Name: wirepas-dlms-tool
Version: 0.1.dev1
Summary: Tool to validate the integration of Wirepas dlms app
Author: Wirepas Ltd
Author-email: opensource@wirepas.com
License: Apache-2
Keywords: Wirepas DLMS HES testing meters
Classifier: Development Status :: 5 - Production/Stable
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: Apache Software License
Classifier: Topic :: Software Development :: Libraries
Classifier: Programming Language :: Python :: 3
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: gurux-dlms ==1.0.143
Requires-Dist: wirepas-mqtt-library ==1.2.3

# dlms-integration-tool
This repository contains tools to validate the integration of Wirepas dlms app


## Wirepas DLMS Tool library

The purpose of the [Wirepas DLMS Integration Tool Python library](./wirepas_dlms_tool/) is to provide tools to validate the DLMS app and the meter compatibility. It is not designed to be used as a HES.<br>
It works as an interface to both the Gurux Python library (to read DLMS/COSEM compatible meters) and the Wirepas MQTT library, and including the specifications of the DLMS app environment.


## Installation with wheel

To build the source distribution and wheel file, make sure you have the wheel package installed
`pip install wheel`

and then run
```
py3clean .
python3 setup.py clean --all
python3 setup.py sdist bdist_wheel
```

It will generate a python wheel for the library in `dist/` folder.

To install a python package from a wheel, you can use the following command:
`pip install <path to the wheel in dist/>`

It will allow to import the library in Python as follow:
`import wirepas_dlms_tool`


## Main principles

The library contains modules to abstract the meters and their NIC in a Wirepas network in order to listen to their traffic and to exchange messages with them from a HES perspective.

In fact, the DLMSNetworkInterface class provides a network interface to communicate with the NIC through the NIC server or directly with the meters in pass-through inside a Wirepas network.
Especially, it redirects the messages from gateways to the corresponding meter objects representing the meters themselves with their NIC.
Futhermore, it also updates locally their network informations (gateway and sink ids) when receiving a message so that meters are always up-to-date.

When a DLMS message is received from an unknown node, the associated meter object is created automatically before redirecting its message.
Put together, it means that it is possible to wait for meters first messages to generate their related meter object.
However, in the case of a proactive communication (requesting the meter), it is still possible to reference the meters manually, as having to wait for a first message for their network information can take unecessary time if we already know their node id, gateway id, sink id.

When requesting a meter, the associated meter object request methods must be used. A response object containing the response error code, the meter response payload, the value that was queried and the xml representation of the response message is returned when the physical meter answers.


When a message is received from the physical meter, the message is either:
* An unencrypted NIC status word message asserting a sink route change or a provisioning request.
* An encrypted data notification.
* A response to a request.
* Something that couldn't be parsed for various reasons (wrong credentials, malformed DLMS packets, ...).

And, in both cases, the message is returned in a different function called by the associated meter object, in order to separate the use cases of the user.


## Examples

Example of proactive request to a meter:
```
# Use for connection to the MQTT.
wni = WirepasNetworkInterface(<mqtt informations>)

# Our network interface to communication with meters.
dni = DLMSNetworkInterface(wni)

# Creation of a meter object.
my_meter = dni.create_meter(node_id=12345678, meter_configuration=my_meter_configuration,
                            gateway="my_gw", sink="my_sink")

# Get meter response of a get device ID request in pass-through in US association.
response = my_meter.get_meter_device_ID(AssociationLevelEnum.US_ASSOCIATION)

# Verification of the correctness of the response with the error code.
assert response.error_code == ErrorCodeEnum.RES_OK

# We can print the response message as a xml string and also its device ID we requested.
print(response.xml)
print(f"The device ID of the meter is {response.value}")
```

Example of listening to unknown meters for its notifications:
```
# Function to be used when receiving a notification from meters.
def default_notification_cb(meter, notification):
    print(f"A notification has been received from {meter.node_id}:")
    print(notification.xml)

# Function to be used when a message could not be parsed.
def unparsed_cb(meter, payload: bytes):
    if meter.meter_configuration:
        print(f"A message from meter {meter.node_id} could not parsed.")
    else:
        print(f"The meter {meter.node_id} sent its first message.")

        # Set meter settings as the object was created automatically a few moment before.
        meter.update_meter(meter_configuration=<my_meter_configuration>)

        # Verify that the message can be parsed as a notification.
        notification = meter.parse_msg_as_notification(payload)

        if notification:
            default_notification_cb(meter, notification)

# Use for connection to the MQTT.
wni = WirepasNetworkInterface(<mqtt informations>)

# Our network interface to communication with meters.
dni = DLMSNetworkInterface(wni, default_notification_cb=default_notification_cb,
        default_unparsed_cb=unparsed_cb)
```


License
-------

Licensed under the Apache License, Version 2.0.
