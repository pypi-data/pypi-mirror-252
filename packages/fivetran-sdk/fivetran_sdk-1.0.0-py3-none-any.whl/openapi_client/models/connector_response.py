# coding: utf-8

"""
    OpenAPI Definition

    The OpenAPI Specification is a standard format to define the structure and syntax of REST APIs. OpenAPI documents are both machine and human-readable, which enables anyone to easily determine how each API works. [More details](https://www.openapis.org/faq)

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.connect_card_config import ConnectCardConfig
from openapi_client.models.connect_card_response import ConnectCardResponse
from openapi_client.models.connector_status_response import ConnectorStatusResponse
from openapi_client.models.setup_test_result_response import SetupTestResultResponse
from typing import Optional, Set
from typing_extensions import Self

class ConnectorResponse(BaseModel):
    """
    ConnectorResponse
    """ # noqa: E501
    id: StrictStr = Field(description="The unique identifier for the group within the Fivetran system.")
    service: StrictStr = Field(description="The name for the connector type within the Fivetran system.")
    var_schema: StrictStr = Field(description="The name used both as the connector's name within the Fivetran system and as the source schema's name within your destination.", alias="schema")
    paused: StrictBool = Field(description="Specifies whether the connector is paused.")
    status: Optional[ConnectorStatusResponse] = None
    config: Optional[Dict[str, Dict[str, Any]]] = Field(default=None, description="The connector setup configuration.")
    daily_sync_time: Optional[StrictStr] = Field(default=None, description="The optional parameter that defines the sync start time when the sync frequency is already set or being set by the current request to 1440. It can be specified in one hour increments starting from 00:00 to 23:00. If not specified, we will use the baseline sync start time. This parameter has no effect on the 0 to 60 minutes offset used to determine the actual sync start time.")
    succeeded_at: Optional[datetime] = Field(default=None, description="The timestamp of the time the connector sync succeeded last time.")
    connect_card: Optional[ConnectCardResponse] = None
    sync_frequency: StrictInt = Field(description="The connector sync frequency in minutes")
    pause_after_trial: StrictBool = Field(description="Specifies whether the connector should be paused after the free trial period has ended.")
    data_delay_threshold: Optional[StrictInt] = None
    group_id: StrictStr = Field(description="The unique identifier for the group within the Fivetran system.")
    connected_by: StrictStr = Field(description="The unique identifier of the user who has created the connector in your account.")
    setup_tests: Optional[List[SetupTestResultResponse]] = Field(default=None, description="Setup tests results")
    source_sync_details: Dict[str, Any] = Field(description="The additional information about the connector's state. The format of this parameter is specific for each connector type.")
    data_delay_sensitivity: Optional[StrictStr] = None
    service_version: Optional[StrictInt] = Field(default=None, description="The connector type version within the Fivetran system.")
    created_at: datetime = Field(description="The timestamp of when the group was created in your account.")
    failed_at: Optional[datetime] = Field(default=None, description="The timestamp of the time the connector sync failed last time.")
    schedule_type: StrictStr = Field(description="The connector schedule config type. Supported values: auto, manual. Lets you disable or enable an automatic data sync on a schedule.")
    connect_card_config: Optional[ConnectCardConfig] = None
    __properties: ClassVar[List[str]] = ["id", "service", "schema", "paused", "status", "config", "daily_sync_time", "succeeded_at", "connect_card", "sync_frequency", "pause_after_trial", "data_delay_threshold", "group_id", "connected_by", "setup_tests", "source_sync_details", "data_delay_sensitivity", "service_version", "created_at", "failed_at", "schedule_type", "connect_card_config"]

    @field_validator('data_delay_sensitivity')
    def data_delay_sensitivity_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('LOW', 'NORMAL', 'HIGH', 'CUSTOM'):
            raise ValueError("must be one of enum values ('LOW', 'NORMAL', 'HIGH', 'CUSTOM')")
        return value

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ConnectorResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of status
        if self.status:
            _dict['status'] = self.status.to_dict()
        # override the default output from pydantic by calling `to_dict()` of connect_card
        if self.connect_card:
            _dict['connect_card'] = self.connect_card.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in setup_tests (list)
        _items = []
        if self.setup_tests:
            for _item in self.setup_tests:
                if _item:
                    _items.append(_item.to_dict())
            _dict['setup_tests'] = _items
        # override the default output from pydantic by calling `to_dict()` of connect_card_config
        if self.connect_card_config:
            _dict['connect_card_config'] = self.connect_card_config.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ConnectorResponse from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "service": obj.get("service"),
            "schema": obj.get("schema"),
            "paused": obj.get("paused"),
            "status": ConnectorStatusResponse.from_dict(obj["status"]) if obj.get("status") is not None else None,
            "config": obj.get("config"),
            "daily_sync_time": obj.get("daily_sync_time"),
            "succeeded_at": obj.get("succeeded_at"),
            "connect_card": ConnectCardResponse.from_dict(obj["connect_card"]) if obj.get("connect_card") is not None else None,
            "sync_frequency": obj.get("sync_frequency"),
            "pause_after_trial": obj.get("pause_after_trial"),
            "data_delay_threshold": obj.get("data_delay_threshold"),
            "group_id": obj.get("group_id"),
            "connected_by": obj.get("connected_by"),
            "setup_tests": [SetupTestResultResponse.from_dict(_item) for _item in obj["setup_tests"]] if obj.get("setup_tests") is not None else None,
            "source_sync_details": obj.get("source_sync_details"),
            "data_delay_sensitivity": obj.get("data_delay_sensitivity"),
            "service_version": obj.get("service_version"),
            "created_at": obj.get("created_at"),
            "failed_at": obj.get("failed_at"),
            "schedule_type": obj.get("schedule_type"),
            "connect_card_config": ConnectCardConfig.from_dict(obj["connect_card_config"]) if obj.get("connect_card_config") is not None else None
        })
        return _obj


