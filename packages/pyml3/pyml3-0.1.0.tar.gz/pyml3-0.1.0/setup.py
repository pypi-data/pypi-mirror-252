# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['expan', 'pyml']

package_data = \
{'': ['*']}

install_requires = \
['pyparsing>=3.1.1,<4.0.0', 'termcolor==2.4.0']

setup_kwargs = {
    'name': 'pyml3',
    'version': '0.1.0',
    'description': 'Library for generating HTML through the use of syntactic macros in python',
    'long_description': '# Pyml\n\nPyml is a python library that allows developers to generate non-static HTML through the use of a custom implementation of syntactic macros for python.\nBy leveraging the power of syntatic macros, pyml offers the familiarity and full feature richness of python, with minimal syntactical overhead.\n\nPyml is framework agnostic and can be used with any web framework/server that supports\nthe returning HTML strings as a response.\n\nPyml is in a very early stage of developmenet. Any feedback, contribuitions or bug reports will be greatly appreciated.\n\n## Installation\n\nPyml can be installed using pip:\n\n```bash\npip install pyml\n```` \n\n## Using pyml\n\nPyml relies on the concept of [syntactic macros](https://en.wikipedia.org/wiki/Macro_(computer_science)) to allow embedding of markup within \npython code. At the time of writing, python does not offer builtin support for syntactic macros (although that might change in the [future](https://peps.python.org/pep-0638/)).\nThe library implements macros by relying on a custom implementation that uses [import hooks](https://docs.python.org/3/reference/import.html) and\na custom file extension.\n\nThere are two steps to using pyml: \n1. Generate html in **.pyxp** files using the **pysx** macro\n2. Import the .pyxp file and access the pysx output\n\nExample: \n```python\n### views.pyxp\n"""\nA .pyxp files is just like a normal python source file, but with one caveat, they can\ncontain macro expressions. A macro expression is just like a normal function call, but\nif the function name is followed by a \'!\', the expression is parsed as a macro call.\n"""\n\nfrom pyml import pysx\n\ntitle = pysx!( \n    h1 {\n        "hello world"\n    }\n)\n\n\n### app.py\nimport pysx.activate # \'pysx.activate\' must appear before importing any .pyxp module\nfrom  .views import title\n\nprint(title) # <h1>hello world</h1>\n```\n\n\n### Elements\n\nThe syntax used with the pysx macro is html-like and was inspired by [rsx](https://dioxuslabs.com/learn/0.4/reference/rsx).\nIn pysx, elements are referenced by the name of the element, followed by their attributes and children in between curly braces: \n```python\nh1 = pysx!(h1 {\n    style: "color:blue", \n    "Hello world"\n}) # expands to: <h1 style="color: blue">Hello world</h1>\n    \n```\nVoid elements like `input` are checked during expansion to make ensure that they don\'t have children: \n```python\nh1 = pysx!(input { "bad child"}) # Error: Void element \'input\' cannot have children\n```\n\n### Expressions\nPysx has the following types of expressions: \n- Numbers: `1, 2, 1.5, 8`\n- Strings: `"Foo", \'Bar\'`\n- Identifiers (Variable reference):`py_var, some_var` \n\nExpressions can be used as attribute values and as the children of elements. `Identifiers` are resolved using python\'s name resolution\nrules: \n```python\nhello_word = "Hello world in a variable"\n\nprint(\n    pysx!(div {\n        hello_word\n    })\n) # expands to: <div>Hello world in variable</div>\n```\n\nThe `py`element allows the use of any arbitary python expression \nwithin a pysx block: \n```python\npysx!(\n    h1{\n        "Even numbers from 1-100: ", \n        div {\n            py { ", ".join([str(i) for i in range(1, 101) if i % 2 == 0]) }\n        }\n    }\n)\n```\n### Conditional rendering\n\nYou can use if statements within rsx to render content conditionally:\n```python\n### if_stmt.pyxp\nfrom pyml import pysx\n\nis_visible = False\n\npage = pysx!(\n    div {\n        if is_visible {\n            "hello world" \n        },\n    }\n) \nprint(page) # <div></div>\n\n\n# You can also use elif and else statements\nlit_type = "string"\npage = pysx!(\n    div {\n        if lit_type == "list_lit" {\n            "[]"\n        }\n        elif lit_type == "float" {\n            "3.14"\n        }\n        elif lit_type == "string" {\n            "Hello world"\n        } else {\n            "unknown type"\n        }\n    }\n) \nprint(page) # <div>Hello world</div>\n```\n\n### Loops\n\nYou can also use for loops within pysx: \n```python\n### for_stmt.pyxp\nfrom pyml import pysx\n\nword_list = ["hello world", "bye world"]\npysx!(\n    div {\n        h1 {\n            "List content" \n        }, \n        for i, word in enumerate(word_list) {\n            b {\n                i\n            }, \n            b {\n                word\n            }\n        } \n    }\n)\n\n```\n\n### Components\n\nComponents are just functions decorated with the \n`pyml.component.component` decorator that return pysx.  \nComponents are invoked with the `props` arg, which is an object that contains\nall the props that the component was initialized with. The `children` prop \nis a special prop that can be used to render the child elements  \npassed to the component: \n```python\n### views.pyxp\nfrom pyml import pysx, component, Props\n\n@component\ndef Scaffold(props: Props):\n    return pysx!(\n        "<!DOCTYPE html>", \n        html {\n            head {\n                meta {\n                    charset: "utf-8"\n                }, \n                meta {\n                    name: "viewport", \n                    content: "width=device-width", \n                    initial-scale: 1\n                } \n            }, \n            body{  \n                style: py { f"background-color: {props.bg_color}" }\n                py { props.children }\n            }, \n        }\n    )\n\ndef index(): \n    return pysx!(\n        Scaffold {\n            bg_color: "red",\n            h1 {\n                "hello world"\n            }\n        }\n    )\n\n```\nTrying to access an unknown prop will result in a runtime error: \n```python\n### views.pyxp\nfrom pyml import pysx, component, Props\n\n@component\ndef Scaffold(props: Props):\n    return pysx!(\n        h1 {\n            py { props.message }\n        }\n    )\n\ndef index(): \n    return pysx!(\n        Scaffold {  \n        } # raises AttributeError: \'Props\' object has no attribute \'message\'. \n    )\n\nprint(index())\n```\nThe above example fails because the `Scaffold` component attempts to get the `message` prop \neven though it wasn\'t invoked with it.\n\n### Debugging pysx\n\nIf you would like to see the expanded version of a .pyxp for debugging or other purposes, without needing to import in another file, \nyou can use the `expan.main` script: \n```bash\npython -m expan.main path/to/pyxp/file.pyxp\n```\nThe above command prints the expanded source to stdout. If you would like send the output to another file, just\nuse the `-o` option: \n```bash\npython -m expan.main path/to/pyxp/file.pyxp -o path/to/output/file.py\n```\n\n## Example(s)\n\nTo see examples of pyml in use, check out the tiny app(s) in the [examples](examples/) folder.\n',
    'author': 'stackswithans',
    'author_email': 'stexor12@gmail.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'None',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.10,<4.0',
}


setup(**setup_kwargs)
