# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['endf_parserpy', 'endf_parserpy.endf_recipes', 'endf_parserpy.fortsource']

package_data = \
{'': ['*'],
 'endf_parserpy.fortsource': ['backup/*',
                              'daniel_20220906/*',
                              'daniel_220808/*']}

install_requires = \
['appdirs>=1.4.0', 'lark>=1.0.0']

setup_kwargs = {
    'name': 'endf-parserpy',
    'version': '0.5.0',
    'description': "A package to read and write ENDF files'",
    'long_description': '# endf-parserpy\n\nThis package can read the content of an\nENDF file into a nested dictionary in Python.\nIt can also generate an ENDF file from\nsuch a nested dictionary. By using additional\npackages, such as the `json` package, ENDF files\ncan be converted from and to other container formats\nas well.\n\nImportantly, for the time being, it expects to find a single\nmaterial in an ENDF file. You can inspect the\nfiles available in the `testdata` directory to\nget a better idea of the ENDF format. The technical\nspecification of the format is provided in the\n[ENDF-6 formats manual].\n\nNoteworthy, this package leverages a formal ENDF format\ndescription, closely following the notation of the\nENDF-6 formats manual, to read, write and verify ENDF-6 formatted files.\nThe capabilities of this package can therefore be extended by\nadding or modifying ENDF recipe files. The already implemented recipe files\ncan be inspected [here](https://github.com/iaea-nds/endf-parserpy/tree/main/endf_parserpy/endf_recipes).\n\nA detailed explanation of the formal ENDF description language used\nin the ENDF recipe files is given in the following [arxiv preprint](https://arxiv.org/abs/2312.08249):\n```\nG. Schnabel, D. L. Aldama, R. Capote, "How to explain ENDF-6 to computers: A formal ENDF format description language", arXiv:2312.08249, DOI:10.48550/arXiv.2312.08249\n```\nPlease use this reference for citation if you find this package useful.\n\n\n[ENDF-6 formats manual]: https://doi.org/10.2172/1425114\n\n## Installation\n\nThis package can be installed via `pip`:\n\n```\npip install endf-parserpy --upgrade\n```\n\nThe only two dependencies of this package are [lark] and [appdirs].\n\n[lark]: https://github.com/lark-parser/lark\n[appdirs]: https://github.com/ActiveState/appdirs\n\n\n## Basic usage\n\nThe essential class implemented in this\npackage is `BasicEndfParser`. It contains the\nmethods `.parsefile` for reading and `.writefile`\nfor writing ENDF-6 files.\nThe following code snippet demonstrates reading\nan ENDF-6 file:\n```\nfrom endf_parserpy import BasicEndfParser\nparser = BasicEndfParser()\nendf_file = \'n_2925_29-Cu-63.endf\'\nendf_dic = parser.parsefile(endf_file)\n```\nThe variable `endf_dic` contains a nested dictionary\nthat exposes all the fields and arrays described in\nthe [ENDF-6 formats manual].\nYou can explore it by using the `.keys()` method, e.g.,\n```\nendf_dic.keys()\n# show the fields of MF2\nendf_dic[2].keys()\n# show the fields of MF2/MT151\nendf_dic[2][151].keys()\n# show the fields of MF2/MT151/isotope\nendf_dic[2][151][\'isotope\'].keys()\n# show fields of first isotope\nendf_dic[2][151][\'isotope\'][1].keys()\n```\nYou can make modifications to these fields and then\nproduce a new ENDF file:\n```\nendf_dic[3][1][\'AWR\'] = 53.47624\nparser.writefile(endf_file + \'.writeback\', endf_dic)\n```\nPlease note that the ENDF dictionary (listing all MF/MT\nsections of the file) in MF1/MT451 is not automatically updated.\nTo update it according to the effected changes,\nuse the `ExtEndfParser` instead of the\n`BasicEndfParser` class (see also next section).\n\nThe following subsections provide short code snippets\nfor common operations or interactions with ENDF files.\n\n### Updating description and MT451 dictionary\n\nIn case the description in MF1/MT451 or\nany other section were modified in ways that may\nresult in a different number of lines in the ENDF file,\nit is better to use the `ExtEndfParser` class.\nIn addition to the methods of the `BasicEndfParser`,\nit offers a few convenience methods, e.g.,\n```\nfrom endf_parserpy import ExtEndfParser\nparser = ExtEndfParser()\nendf_dic = parser.parsefile(endf_file)\ndescr = parser.get_description(endf_dic)\nprint(descr)\nnewinfo = \'We tweaked the data in MF3...\\nJust joking!\'\nparser.insert_description(endf_dic, newinfo, after_line=5)\nparser.writefile(\'modified_file.endf\', endf_dic)\n```\n\nThe updating of the dictionary in MF1/MT451 can also\nbe done without writing a file to disk:\n```\nparser.update_dictionary(endf_dic)\n```\n\n### Convenient syntax to navigate ENDF-6 data\n\nThe class `EndfDict` makes access\nto variables in the nested Python dictionaries more\nconvenient. Suppose you read ENDF-6 data into the\nvariable `endf_dic` (as above). To create a view object\nassociated with `endf_dic`, execute\n```\nfrom endf_parserpy.accessories import EndfDict\nbetter_endf_dic = EndfDict(endf_dic)\n```\nNow you can use more concise syntax to refer\nto specific variables in the nested dictionary.\nFor instance, the following two lines retrieve\nthe same piece of information:\n```\n# awr = endf_dic[3][1][\'AWR\']\nawr = better_endf_dic[\'3/1/AWR\']\n```\n\nSimilarly, the following two lines are equivalent to set\na variable value:\n```\n# endf_dic[2][151][\'isotope\'][1][\'ZAI\'] = 26054\nbetter_endf_dic[\'2/151/isotope/1/ZAI\'] = 26054\n```\nAs `better_endf_dic` is a view, any changes to it\nwill also be applied to `endf_dic`.\n\nBrackets may also be used in the index and the following\nlines are therefore also equivalent in their effect:\n```\nbetter_endf_dic[\'2/151/isotope/1/ZAI\'] = 26054\nbetter_endf_dic[\'2/151/isotope[1]/ZAI\'] = 26054\n```\nImportantly, in such variable assignments,\nintermediate dictionaries will be created as required.\n\n\n### Selective parsing\n\nIf one is only interested in specific MF/MT numbers,\nit is possible to include or exclude the desired sections\nto accelerate the parsing process.\nFor instance, only including MF1/MT451 and MF3 can be\ndone by:\n```\nendf_dic = parser.parsefile(\'n_2925_29-Cu-63.endf\', include=(3, (1,451)))\n```\nAll other sections will then only be available as strings. To include a\nsingle section, use `include=(MF,)` or `include=((MF,MT),)`.\n\nExcluding sections can be done analogously. To parse every section\nexcept the specified sections use:\n```\nendf_dic = parser.parsefile(\'n_2925_29-Cu-63.endf\', exclude=(3, (1,451)))\n```\nYou can always retrieve a list of the parsed and unparsed sections by:\n```\nfrom endf_parserpy.user_tools import list_parsed_sections, list_unparsed_sections\nlist_parsed_sections(endf_dic)\nlist_unparsed_sections(endf_dic)\n```\n\n### Convenience functions\n\nThere are a few user convenience functions available.\nThis code snippet finds all locations where a variable\nof a specific name appears and shows their values:\n```\nfrom endf_parserpy.user_tools import locate, get_endf_values\nlocations = locate(endf_dic, \'AWR\')\nvalues = get_endf_values(endf_dic, locations)\n```\nThe following function aims to provide a nicer\nvisual representation of the content of a section\n(or any subsection within):\n```\nfrom endf_parserpy.user_tools import show_content\nshow_content(endf_dic[1][451])\n```\n\n### Deleting, substituting, modifying MF/MT sections\n\nBasic functionality to deal with Python dictionaries\ncan be used to delete, substitute or modify sections\nin ENDF files.\nTo delete a section, e.g., MF3, you can use\n```\ndel endf_dic[3]\n```\nTo delete a subsection, e.g., MF1/MT451, execute\n```\ndel endf_dic[1][451]\n```\n\nSubstituting a section by one from another\nENDF file can be done like this:\n```\nfrom copy import deepcopy\nendf_dic1 = parser.parsefile(\'n_2925_29-Cu-63.endf\')\nendf_dic2 = parser.parsefile(\'n_3025_30-Zn-64.endf\')\nendf_dic1[3][1] = deepcopy(endf_dic2[3][1])\nparser.writefile(\'replaced.endf\', endf_dic1)\n```\n\nModifying a number is very easy and can be\nachieved by, e.g.,\n```\nendf_dic[1][451][\'AWR\'] = 63\n```\n\n### Converting between ENDF and JSON files\n\nEquivalent JSON files can be produced from ENDF files\nwith this code snippet:\n```\nfrom endf_parserpy import BasicEndfParser\nimport json\nparser = BasicEndfParser()\nendf_dic = parser.parsefile(endf_filepath)\nwith open(\'endf_file.json\', \'w\') as f:\n    json.dump(endf_dic, f, indent=2)\n```\n\nTo convert a JSON file back to an ENDF file, you can\nuse this code:\n```\nfrom endf_parserpy.user_tools import sanitize_fieldname_types\nwith open(\'endf_file.json\', \'r\') as f:\n    endf_dic = json.load(f)\n\nsanitize_fieldname_types(endf_dic)\nparser.writefile(\'endf_out.endf\', endf_dic, overwrite=True)\n```\nKeys of type integer in Python are converted to type string\nby `json.dump`. The function `sanitize_fieldname_types` restores the\ninteger type of the keys after reading from a JSON file and\nbefore passing them to `parser.writefile`.\n\n### Precision control for ENDF file output\n\nSome options can be provided to increase the\nprecision of outputted ENDF files by passing\nspecific options to the constructor:\n```\nfrom endf_parserpy import BasicEndfParser\nparser = BasicEndfParser(prefer_noexp=True,\n    abuse_signpos=True, skip_intzero=True)\nparser.writefile(\'endf_output.endf\', endf_dic)\n```\nIf you prefer better compatibility for languages\ndifferent from Fortran at the cost of losing\none digit precision, you can also add\n`keep_E=True` to the argument list.\n\n### Comparing ENDF files\n\nIf two files are believed to be equivalent or to have only\nminor differences, they can be compared in the following way:\n```\nfrom endf_parserpy import BasicEndfParser\nfrom endf_parserpy.debugging_utils import compare_objects\nparser = BasicEndfParser()\nendf_dic1 = parser.parsefile(\'n_2925_29-Cu-63.endf\')\nendf_dic2 = parser.parsefile(\'n_3025_30-Zn-64.endf\')\ncompare_objects(endf_dic1, endf_dic2, fail_on_diff=False)\n```\n\nYou can also add the `atol` and `rtol` arguments to the\n`compare_objects` call to control the absolute and relative\ntolerance, respectively, in the comparison of floating point\nnumbers. These arguments have the same meaning as for the\n`numpy.isclose` function. The default values are\n`atol=1e-8` and `rtol=1e-6`. You may want to use this function\nto check that you don\'t lose too much precision in a reading,\nadjustment, writing sequence:\n```\nendf_dic1 = parser.parsefile(\'n_2925_29-Cu-63.endf\')\n# ...\n# introduce some modifications in endf_dic1,\n# e.g., changing numbers, substituting sections\nendf_out = \'modified_n_2925_29-Cu-63.endf\'\nparser.writefile(endf_out, endf_dic1)\nendf_dic2 = parser.parsefile(endf_out)\ncompare_objects(endf_dic1, endf_di2, fail_on_diff=False)\n```\nIf inacceptable differences are detected, you may want\nuse the available arguments discussed\n[above](#precision-control-for-endf-file-output) to\nincrease the output precision.\n\n## Testing\n\nThe development of this package relies on `pytest` to ensure\nthe proper implementation of the ENDF-6 recipes. As most of\nthe recipes have already been implemented, the testing\nfunctionality can be also used to validate ENDF-6 formatted\nfiles. For a convenient workflow, install the Python package\n`poetry`, clone this repository, and create a virtual environment\nwith all dependencies:\n```\npip install poetry\ngit clone https://github.com/iaea-nds/endf-parserpy\ncd endf-parserpy\npoetry install\n```\nTo start a testing session, change into the directory\n`tests` within the repository directory and run\n```\npoetry shell\n```\nNow you can check if endf-parserpy is able to parse\nENDF files in a directory `<endfdir>` by executing\n```\npytest --endfdir=<endfdir> -k test_endf_parserpy_never_fails\n```\nThis command will read and check all ENDF files\nwith the file ending `.endf` in the specified directory.\nAdditional available arguments are:\n\n- `--endffile=<endffile>` to only test a single ENDF file within `<endfdir>`.\n- `--mf=<mfnum>` will restrict parsing to the MF section `<mfnum>`\n- `--ignore_zero_mismatch=false` to let the conversion fail for non-zero fields in the ENDF file if the ENDF-6 format specifies them to be zero.\n- `--ignore_number_mismatch=true` will lead to less strict checking that tolerates any non-zero number in the ENDF file contradicting the expected number\n                                  in the ENDF recipe if the latter number is suffixed by a question mark.\n- `--ignore_varspec_mismatch=true` will lead to less strict checking that tolerates any inconsistent variable specification if the variable name in the\n                              ENDF recipe is suffixed by a question mark.\n\n## Acknowledgments\n\nThe IAEA consultant Daniel Lopez Aldama helped with his great knowledge\non the ENDF-6 format to guide through the complexities of the format\nin numerous discussions and also greatly contributed to the\ndebugging of the recipe files.\n\n## Legal note\n\nThis code is distributed under the MIT license, see the\naccompanying license file for more information.\n\nCopyright (c) International Atomic Energy Agency (IAEA)\n\n[ENDF-6 formats manual]: https://oecd-nea.org/dbdata/data/manual-endf/endf102.pdf\n',
    'author': 'Georg Schnabel',
    'author_email': 'None',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/iaea-nds/endf-parserpy',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.6',
}


setup(**setup_kwargs)
