from functools import partial
from pathlib import Path
from contextlib import suppress
from configparser import ConfigParser
from os import symlink, makedirs, remove
from os.path import (
    dirname,
    exists,
    join,
    relpath as relative_path,
    islink,
    realpath,
)

import tomlkit
import json

from ruamel.yaml import YAML
from tomlkit.items import Array, Trivia

from omniblack.cli import CLI


from .display import error
from .base_package import find_packages, find_root
from .languages import langs, Languages
from .model import model

yaml = YAML()


class pkg_func:
    def __new__(cls, func=None, lang=None):
        # Partial decorator call
        if lang is None and isinstance(func, Languages):
            return partial(cls, lang=func)

        return super().__new__(cls)

    def __init__(self, func, lang=None):
        self.__wrapped__ = func
        self.__wrapped__.lang = lang

    def __set_name__(self, owner, name):
        pkg_funcs = getattr(owner, 'pkg_funcs', tuple())
        pkg_funcs = pkg_funcs + (self.__wrapped__, )
        owner.pkg_funcs = pkg_funcs
        setattr(owner, name, self.__wrapped__)


def set_path(target, path, value):
    segments = path.split('.')
    last_segment = segments.pop()

    for seg in segments:
        target = target.setdefault(seg, {})

    target[last_segment] = value


marker_line = '# Editable deps are autogenerated'


app = CLI(model)


@app.command
class sync_metadata:
    """
    %(prog)s syncs metadata in the monorepo.

    %(prog)s syncs metadata such as LICENSE.txt and the license fields,
        version fields, names, and build systems.

    Args:
        one: This is the first arg.
    """

    def editable_lines(self, pkgs):
        for pkg in pkgs:
            if not pkg.py.is_extenstion:
                yield f'-e {relative_path(pkg.path, self.root)}\n'
            else:
                yield f'{relative_path(pkg.path, self.root)}\n'

            dev_req_file = join(pkg.path, 'dev-requirements.txt')

            if dev_req_file.exists():
                yield f'-r {relative_path(dev_req_file, self.root)}\n'

            yield '\n'

    def write_editable_reqs(self, pkgs):
        py_pkgs = (
            pkg
            for pkg in pkgs
            if pkg.py
        )

        py_pkgs = sorted(py_pkgs, key=lambda pkg: pkg.name)

        editable_deps = self.editable_lines(py_pkgs)

        req_file = join(self.root, 'dev-requirements.txt')
        lines = []
        with open(req_file, 'r+') as file:
            # Get the third party, repo wide, requirements
            for line in file:
                lines.append(line)

                # The line with the double hash comment
                # is the start of the editable deps
                if line.startswith('##'):
                    break

            file.seek(0)
            file.truncate()
            file.seek(0)
            lines.extend(editable_deps)

            file.writelines(lines)

    @pkg_func(Languages.js)
    def update_js(self, pkg):
        js = pkg.js.manifest
        path = pkg.path

        if js['name'] == '@omniblack/rollup-plugin-html-template':
            return

        pkg_dir = relative_path(path, self.root)
        homepage = self.homepage_root + pkg_dir
        js_repo = {
            'directory': pkg_dir,
            'type': 'git',
            'url': self.git_url,
        }

        license = self.get_license(pkg)

        js['repository'] = js_repo
        js['license'] = license['id']
        js['author'] = self.authors[0]
        if len(self.authors) > 1:
            js['contributors'] = self.authors[1:]

        js['homepage'] = homepage

        if 'exports' in js and './package.json' not in js['exports']:
            js['exports']['./package.json'] = './package.json'

        js.setdefault('imports', {})

        js['imports']['#src/*'] = (
            './' + relative_path(pkg.src_dir, path) + '/*'
        )
        js['imports']['#pkg/*'] = './*'

    def get_license(self, pkg):
        if pkg.config.license:
            return pkg.config.license
        else:
            return self.license

    @pkg_func(Languages.py)
    def update_py(self, pkg):
        py = pkg.py.manifest
        path = pkg.path

        pkg_dir = relative_path(path, self.root)
        homepage = self.homepage_root + pkg_dir

        license = self.get_license(pkg)
        py['project']['license'] = license
        py['project']['authors'] = self.authors

        set_path(py, 'project.urls.Homepage', homepage)
        set_path(py, 'project.urls.Repository', self.git_url)

        if not pkg.py.is_extenstion:
            set_path(py, 'tool.setuptools.packages.find.where', ['src'])
            set_path(py, 'tool.setuptools.packages.find.include', ['*'])
            set_path(py, 'tool.setuptools.package-data.*', ['*'])

    @pkg_func(Languages.py)
    def py_build_setup(self, pkg):
        py = pkg.py.manifest
        set_path(py, 'build-system.build-backend', 'setuptools.build_meta')

        requires = ['setuptools ~= 68.2']

        if pkg.py.is_extenstion:
            requires.append('setuptools-rust ~= 1.8')
            ext_modules = [{'target': pkg.py.canonical_name}]
            set_path(py, 'tool.setuptools-rust.ext-modules', ext_modules)

        requires = Array(
            [
                tomlkit.string(req)
                for req in requires
            ],
            multiline=True,
            trivia=Trivia(),
        )

        set_path(py, 'build-system.requires', requires)

    @pkg_func(Languages.py)
    def setup_manifest_in(self, pkg):
        manifest_lines = []
        manifest_path = join(pkg.path, 'MANIFEST.in')

        if pkg.py.is_extenstion:
            manifest_lines.extend((
                'include Cargo.toml',
                'include Cargo.lock',
                'recursive-include src *',
            ))

        if exists(join(pkg.path, 'docs')):
            manifest_lines.append(
                'recursive-include docs *.md *.rst',
            )

        if not manifest_lines:
            with suppress(FileNotFoundError):
                remove(manifest_path)
        else:
            with open(manifest_path, 'w') as file:
                file.write('\n'.join(manifest_lines))

    @pkg_func(Languages.py)
    def setup_cfg(self, pkg):
        setup_cfg_path = join(pkg.path, 'setup.cfg')

        if not pkg.py.is_extenstion:
            with suppress(FileNotFoundError):
                remove(setup_cfg_path)
        else:
            config = ConfigParser()
            config['bdist_wheel'] = {}
            config['bdist_wheel']['py-limited-api'] = 'cp37'

            with open(setup_cfg_path, 'w') as file:
                config.write(file, space_around_delimiters=False)

    @pkg_func(Languages.rs)
    def update_rs(self, pkg):
        rs = pkg.rs.manifest

        pkg_dir = join(pkg.path, self.root)
        homepage = self.homepage_root + pkg_dir
        authors = [
            f'{author["name"]} <{author["email"]}>'
            for author in self.authors
        ]

        set_path(rs, 'package.license', self.license['id'])
        set_path(rs, 'package.license-file', self.license['file'])
        set_path(rs, 'package.authors', authors)
        set_path(rs, 'package.repository', self.repo_html)
        set_path(rs, 'package.homepage', homepage)

        if pkg.py and pkg.py.is_extenstion:
            set_path(rs, 'package.publish', False)
            set_path(rs, 'lib.crate-type', ['cdylib'])

    @pkg_func
    def link_license(self, pkg):
        if pkg.config.license:
            return

        license_path = Path(
            relative_path(join(self.root, self.license_file), pkg.path),
        )

        link_path = join(pkg.path, self.license_file)

        if exists(link_path):
            if not islink(link_path) or realpath(link_path) != license_path:
                error.print(f'{pkg.name} has non-link {self.license_file}')

            return

        link_path.symlink_to(license_path)

    @pkg_func(Languages.py)
    def link_docs(self, pkg):
        pkg_docs = join(pkg.path, 'docs')

        if not exists(pkg_docs):
            return

        root_docs = join(self.root, 'docs')
        rel_pkg_docs = dirname(relative_path(pkg_docs, self.root))
        link_path = join(root_docs, rel_pkg_docs)

        makedirs(dirname(link_path), exist_ok=True)

        with suppress(FileExistsError):
            symlink(pkg_docs, link_path)

    def __init__(self):
        self.root = find_root()
        repo_def_path = join(self.root, 'omniblack.yaml')
        with open(repo_def_path) as file:
            repo_def = yaml.load(file)

        repo_def = repo_def['repo']

        self.license = repo_def['license']
        self.license_file = repo_def['license']['file']
        self.authors = repo_def['authors']
        self.git_url = repo_def['urls']['repo_git']
        self.repo_html = repo_def['urls']['repo_html']
        self.homepage_root = repo_def['urls']['homepage_root']

        pkgs = find_packages(self.root)
        self.write_editable_reqs(pkgs)

        for pkg in pkgs:
            for func in self.pkg_funcs:
                if func.lang is not None:
                    lang_def = langs[func.lang]
                    lang = getattr(pkg, lang_def.attr)
                    if lang is None:
                        continue

                func(self, pkg)

            if pkg.py:
                with open(pkg.py.path, mode='w') as py_file:
                    tomlkit.dump(pkg.py.manifest, py_file)

            if pkg.js:
                with open(pkg.js.path, mode='w') as js_file:
                    json.dump(pkg.js.manifest, js_file, indent=4)

            if pkg.rs:
                with open(pkg.rs.path, mode='w') as rs_file:
                    tomlkit.dump(pkg.rs.manifest, rs_file)
