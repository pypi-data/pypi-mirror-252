"""!
@file
Cluster/single pointing models for making SZ maps.
Additionally, this file contains a class that is useful for investigating scattering kernels and electron distributions.
"""

import numpy as np

import MockSZ.Bindings as MBind

TSZ_LABEL     = "MaxwellJuttner"
NTSZ_LABEL    = "RelativisticPowerlaw"

class IsoBetaModel(object):
    """!
    Class representing an isothermal-beta model.
    Should be instantiated and serves as an interface for MockSZ when simulating these types of clusters.

    @ingroup clustermodels
    """
    
    def getIsoBeta(self, Az, El, ibeta, ne0, thetac, Da, grid=False):
        """!
        Get an isothermal-beta optical depth screen. 

        @param Az Numpy array containing the range of Azimuth co-ordinates, in arcseconds.
        @param El Numpy array containing the range of Elevation co-ordinates, in arcseconds.
        @param ibeta Beta parameter for isothermal model.
        @param ne0 Central electron number density, in number / cm**3.
        @param thetac Angular cluster core radius, in arcseconds.
        @param Da Angular diameter distance to cluster, in Megaparsec.
        @param grid Whether or not to evaluate the model on a 2D grid spanned by Az and El, or on a 1D trace.
            If grid=True, the screen will be of size Az.size * El.size.
            If grid=False (default), it is required that Az.size ==  El.size, and the screen will be of size Az.size = El.size.

        @returns res The optical depth screen.
        """

        res = MBind.getIsoBeta(Az, El, ibeta, ne0, thetac, Da, grid)
        return res
    
    def getIsoBetaCube(self, isobeta, nu_arr, Te, v_pec, n_s=500, n_beta=500, n_mu=500, no_CMB=False):
        """!
        Get an isothermal-beta model from an optical depth screen.

        @param isobeta An optical depth screen generated by self.getIsoBeta.
        @param nu_arr Numpy array of frequencies for SZ effect, in Hz.
        @param Te Electron temperature, in keV.
        @param v_pec Peculiar cluster velocity, in km / s.
        @param n_s Number of logarithmic frequency shifts to include.
        @param n_beta Number of dimensionless electron velocities to include.
        @param no_CMB Whether to add CMB to SZ signal or not.
        
        @returns res 2D or 3D grid (depending on dimensions of isobeta) containing SZ signal attenuated by optical depth in isobeta.
        """

        res_tSZ = MBind.getSinglePointing_t_ntSZ(nu_arr, Te, tau_e=1, dist=TSZ_LABEL, n_s=n_s, n_beta=n_beta, no_CMB=True)
        res_kSZ = MBind.getSinglePointing_kSZ(nu_arr, v_pec, tau_e=1, n_mu=n_mu)
        
        res_SZ = res_tSZ + res_kSZ


        if len(isobeta.shape) == 1:
            shape = (isobeta.size, nu_arr.size)
            res = np.ones(shape)
            for i in range(nu_arr.size):
                res[:,i] = isobeta
        else:
            shape = (isobeta.shape[0], isobeta.shape[1], nu_arr.size)
            res = np.ones(shape)
            for i in range(nu_arr.size):
                res[:,:,i] = isobeta

        res *= res_SZ
        
        if no_CMB == False:
            res += MBind.getCMB(nu_arr)
        
        return res

class SinglePointing(object):
    """! 
    Class for generating a single pointing SZ signal. Can choose between tSZ, kSZ and ntSZ (powerlaw).
    
    @ingroup singlepointing
    """

    def getSingleSignal_tSZ(self, nu_arr, Te, tau_e=0.01, n_s=500, n_beta=500, no_CMB=False):
        """!
        Generate a single pointing signal of the tSZ effect.

        @param nu_arr Numpy array of frequencies for tSZ effect, in Hz.
        @param Te Electron temperature, in keV.
        @param tau_e Optical depth along sightline.
        @param n_s Number of logarithmic frequency shifts to include.
        @param n_beta Number of dimensionless electron velocities to include.
        @param no_CMB Whether to add CMB to tSZ signal or not.
        
        @returns res 1D array containing tSZ effect.
        """

        res = MBind.getSinglePointing_t_ntSZ(nu_arr, Te, tau_e, TSZ_LABEL, n_s, n_beta, no_CMB)
        return res
    
    def getSingleSignal_ntSZ(self, nu_arr, alpha, tau_e=0.01, n_s=500, n_beta=500, no_CMB=False):
        """!
        Generate a single pointing signal of the ntSZ effect, according to a powerlaw.

        @param nu_arr Numpy array of frequencies for ntSZ effect, in Hz.
        @param alpha Slope of powerlaw.
        @param tau_e Optical depth along sightline.
        @param n_s Number of logarithmic frequency shifts to include.
        @param n_beta Number of dimensionless electron velocities to include.
        @param no_CMB Whether to add CMB to ntSZ signal or not.
        
        @returns res 1D array containing ntSZ effect.
        """

        res = MBind.getSinglePointing_t_ntSZ(nu_arr, alpha, tau_e, NTSZ_LABEL, n_s, n_beta, no_CMB)

        return res
    
    def getSingleSignal_kSZ(self, nu_arr, v_pec, tau_e=0.01, n_mu=500):
        """!
        Generate a single pointing signal of the kSZ effect.

        Note that this method, in contrast to the other methods in this class, only returns the CMB distortion.
        The CMB can be added by adding the kSZ signal to a tSZ or ntSZ signal containing the CMB.

        @param nu_arr Numpy array of frequencies for kSZ effect, in Hz.
        @param v_pec Peculiar velocity.
        @param tau_e Optical depth along sightline.
        @param n_mu Number of scattering direction cosines to include.
        
        @returns res 1D array containing kSZ effect.
        """

        res = MBind.getSinglePointing_kSZ(nu_arr, v_pec, tau_e, n_mu)

        return res

class ScatteringKernels(object):
    """!
    Class for investigating the scattering kernels.
    It is not to be used per se for simulations, but it provides a nice overview of available distributions.
    In addition, it is helpful for troubleshooting and debugging to have access to the scattering kernels directly.
    So, it is mostly informative, and not meant to be used during actual simulations.
    """

    def getSingleScattering(self, s_arr, beta, num_mu=1000):
        """!
        Obtain single-electron scattering kernel, for a range of s and a single beta.
        This method assumes a Thomson scattering in the electron rest frame.

        @param s_arr Numpy array of logarithmic frequency shifts s.
        @param beta Dimensionless electron velocity.
        @param n_mu Number of scattering direction cosines to include.

        @returns res 1D array containing single-electron scattering probabilities.
        """
        
        res = MBind.getSingleScattering(s_arr, beta, num_mu)

        return res
    
    def getMaxwellJuttner(self, beta_arr, Te):
        """!
        Obtain a Maxwell-Juttner distribution.

        @param beta_arr Numpy array of dimensionless electron velocities.
        @param Te Electron temperature in keV.

        @returns res 1D array containing Maxwell-Juttner distribution.
        """
        
        res = MBind.getElectronDistribution(beta_arr, Te, TSZ_LABEL)

        return res
    
    def getPowerlaw(self, beta_arr, alpha):
        """!
        Obtain a relativistic powerlaw distribution.

        @param beta_arr Numpy array of dimensionless electron velocities.
        @param alpha Slope of powerlaw.

        @returns res 1D array containing relativistic powerlaw distribution.
        """
        
        res = MBind.getElectronDistribution(beta_arr, alpha, NTSZ_LABEL)

        return res
    
    def getMultiScatteringMJ(self, s_arr, Te, n_beta=500):
        """!
        Obtain multi-electron scattering kernel, for a range of beta.
        This kernel is calculated using a Maxwell-Juttner distribution.

        @param s_arr Numpy array of logarithmic frequency shifts s.
        @param Te Electron temperature in keV.
        @param n_beta Number of dimensionless electron velocities to include.

        @returns res 1D array containing mulit-electron scattering probabilities.
        """
        
        res = MBind.getMultiScattering(s_arr, Te, TSZ_LABEL, n_beta)

        return res
    
    def getMultiScatteringPL(self, s_arr, alpha, n_beta=500):
        """!
        Obtain multi-electron scattering kernel, for a range of beta.
        This kernel is calculated using a relativistic powerlaw distribution.

        @param s_arr Numpy array of logarithmic frequency shifts s.
        @param alpha Slope of powerlaw.
        @param n_beta Number of dimensionless electron velocities to include.

        @returns res 1D array containing mulit-electron scattering probabilities.
        """
        
        res = MBind.getMultiScattering(s_arr, alpha, NTSZ_LABEL, n_beta)

        return res
