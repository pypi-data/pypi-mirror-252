import shutil
import tempfile
from pathlib import Path

import click

import sym.flow.cli.helpers.output as cli_output
from sym.flow.cli.helpers.code_generation.migration.migrate import CodeGenerationMigrator
from sym.flow.cli.helpers.global_options import GlobalOptions
from sym.flow.cli.helpers.tracked_command import TrackedCommand


@click.command(cls=TrackedCommand, short_help="Automatically migrate symflow generated Terraform configurations")
@click.make_pass_decorator(GlobalOptions, ensure=True)
@click.option(
    "--directory",
    help="The path to the directory created by `symflow init`.",
    default=".",
)
@click.option(
    "--dry-run",
    is_flag=True,
    help="Generate a diff of the expected migration changes, without applying them.",
)
def migrate(options: GlobalOptions, directory: str, dry_run: bool) -> None:
    """Attempts to migrate Terraform configuration files generated by previous symflow versions to be compatible
    with the current symflow version.
    """

    if not Path(f"{directory}/environment.tf").is_file() or not Path(f"{directory}/versions.tf").is_file():
        cli_output.fail(
            "This command can only be used to migrate files created by `symflow init` and `symflow generate`.",
            hint=f"Hint: The directory must have `environment.tf` and `versions.tf` files.",
        )

    existing_tf_files = list(Path(directory).glob("*.tf"))

    # Don't try to re-run the migration if a migration_v8.tf file already exists
    if Path(directory) / "migration_v8.tf" in existing_tf_files:
        cli_output.success("A 'migration_v8.tf' already exists! Your configuration does not require any migrations.")
        return

    # Apply the migrations in a temporary directory, which we will copy to the target directory if we successfully
    # generate all the files.
    with tempfile.TemporaryDirectory() as tmpdir:
        # Copy all the TF files into a temporary directory to modify.
        for file_path in existing_tf_files:
            shutil.copy(file_path, tmpdir)

        # A migrator tool that will generate files in this temporary directory.
        migrator = CodeGenerationMigrator(options=options, working_directory=tmpdir, target_directory=directory)
        try:
            # Migrate runtime.tf and connectors.tf
            migrator.migrate_connector_modules()

            # Migrate secrets.tf
            migrator.migrate_secrets_tf()

            # Replace all aws_iam_role and sym_runtime references and commented symflow CLI versions
            migrator.refactor_references()

            # Generate the migration_v8.tf file, if necessary
            migrator.generate_moved_blocks()

            # Attempt to validate the migration produced valid Terraform by running `terraform fmt`
            migrator.validate_migration()

            # Check the diff to see if any changes were actually made.
            diff = migrator.generate_diff()

            # We only need to generate a backup zip if this is not a dry-run, and changes were made
            if not dry_run and diff:
                # Backup the impls/, .*tf files, and *.tfstate files in the target directory into a zip
                backup_filepath = migrator.backup_existing_files()
        except Exception as e:
            options.dprint(f"An exception was raised while generating the migration changes: {repr(e)}")
            migrator.fail_migration("Your configuration could not be migrated due to an unknown error.")

        # If there were no changes, then just exit successfully.
        if not diff:
            cli_output.success("Your configuration does not require any migrations.")
            return

        if dry_run:
            # If this is a dry-run, just output the diff and exit
            click.echo(diff)
        else:
            # Update the actual directory files
            try:
                migrator.apply_migration()
                cli_output.success(
                    f"Your Terraform configuration was successfully migrated! "
                    f"\nA copy of your previous configuration files has been saved to '{backup_filepath}'."
                )
            except Exception as e:
                options.dprint(f"An exception was raised while applying migration changes: {repr(e)}")
                migrator.fail_migration(
                    "An unexpected error occurred while updating your configuration. "
                    f"Your files might be in a bad state. A backup of your original configuration has been saved to '{backup_filepath}'."
                )
